"""
Nikto Web Vulnerability Scanner Tool
Wrapper for the Nikto web server scanner
"""

import os
import json
import tempfile
from typing import Dict, Any
from .base_tool import BaseTool


class NiktoTool(BaseTool):
    """Nikto web vulnerability scanner implementation"""

    def __init__(self):
        super().__init__()
        self.name = "nikto"
        self.description = "Web server vulnerability scanner"

        # Find nikto executable
        self.tool_path = self._find_nikto_path()

    def _find_nikto_path(self) -> str:
        """Find nikto executable path"""
        username = os.getenv("USERNAME", os.getenv("USER", "user"))

        possible_paths = [
            # Project tools (wrapper scripts)
            rf"C:\Users\{username}\Documents\My Files\Programes\IITM\Subd_IITM\tools\nikto",
            # Direct Perl script
            rf"C:\Users\{username}\security-tools\nikto\program\nikto.pl",
            # System installations
            "/usr/bin/nikto",
            "/usr/local/bin/nikto",
            "nikto",  # Fallback to PATH
        ]

        return self._find_tool_path(possible_paths)

    def get_description(self) -> str:
        return f"Nikto Web Vulnerability Scanner - Scans web servers for vulnerabilities, misconfigurations, and security issues. Path: {self.tool_path}"

    def get_input_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "target": {
                    "type": "string",
                    "description": "Target URL, IP address, or hostname to scan",
                },
                "port": {
                    "type": "integer",
                    "description": "Port to scan (default: 80 for HTTP, 443 for HTTPS)",
                    "default": 80,
                    "minimum": 1,
                    "maximum": 65535,
                },
                "ssl": {
                    "type": "boolean",
                    "description": "Use SSL/HTTPS for the scan",
                    "default": False,
                },
                "timeout": {
                    "type": "integer",
                    "description": "Request timeout in seconds",
                    "default": 10,
                    "minimum": 1,
                    "maximum": 300,
                },
                "user_agent": {
                    "type": "string",
                    "description": "Custom User-Agent string",
                    "default": "Mozilla/5.0 (compatible; Nikto)",
                },
                "plugins": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "Specific Nikto plugins to use (optional)",
                },
                "arguments": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "Additional nikto command-line arguments",
                },
            },
            "required": ["target"],
        }

    async def execute(self, params: Dict[str, Any]) -> str:
        """Execute Nikto web vulnerability scan"""
        try:
            # Validate and extract parameters
            target = self._validate_target(params["target"])
            port = params.get("port", 80)
            use_ssl = params.get("ssl", False)
            timeout = params.get("timeout", 10)
            user_agent = params.get("user_agent", "Mozilla/5.0 (compatible; Nikto)")
            plugins = params.get("plugins", [])
            extra_args = params.get("arguments", [])

            # Auto-detect SSL if target has https or port 443
            if "https://" in target.lower() or port == 443:
                use_ssl = True
                if port == 80:  # Reset to default HTTPS port
                    port = 443

            # Build the command
            cmd = self._build_command(
                target, port, use_ssl, timeout, user_agent, plugins, extra_args
            )

            # Execute the scan
            result = await self._execute_command(
                cmd, timeout=(timeout * 10) + 60
            )  # Allow extra time for tool overhead

            # Format and return results
            return self._format_results(target, result, params)

        except ValueError as e:
            return self._format_error_response(
                str(e),
                suggestions=[
                    "Check target format (e.g., example.com, 192.168.1.1)",
                    "Ensure target is accessible",
                ],
            )
        except Exception as e:
            return self._format_error_response(
                f"Nikto execution failed: {str(e)}",
                suggestions=[
                    "Verify Nikto is installed and accessible",
                    "Check target connectivity",
                    "Review command parameters",
                ],
            )

    def _build_command(
        self,
        target: str,
        port: int,
        use_ssl: bool,
        timeout: int,
        user_agent: str,
        plugins: list,
        extra_args: list,
    ) -> list:
        """Build the nikto command"""

        # Determine how to execute nikto
        if self.tool_path.endswith(".pl"):
            cmd = ["perl", self.tool_path]
        elif os.name == "nt" and not self.tool_path.endswith(".exe"):
            # On Windows, might need to use bash for WSL wrapper
            cmd = ["bash", self.tool_path]
        else:
            cmd = [self.tool_path]

        # Build target URL
        if use_ssl:
            target_url = f"https://{target}:{port}"
        else:
            target_url = f"http://{target}:{port}"

        # Add core arguments
        cmd.extend(
            [
                "-h",
                target_url,
                "-timeout",
                str(timeout),
                "-ask",
                "no",  # Don't ask interactive questions
                "-Pause",
                "0",  # No pause between requests
            ]
        )

        # Add user agent
        if user_agent:
            cmd.extend(["-useragent", user_agent])

        # Add specific plugins if requested
        if plugins:
            cmd.extend(["-Plugins", ",".join(plugins)])

        # Try to get structured output
        cmd.extend(["-Format", "csv"])  # CSV is more reliable than JSON

        # Add any additional arguments
        cmd.extend(extra_args)

        return cmd

    def _format_results(
        self, target: str, result: Dict[str, Any], params: Dict[str, Any]
    ) -> str:
        """Format Nikto scan results"""

        response = "# 🔍 Nikto Web Vulnerability Scan Results\n\n"
        response += f"**Target:** {target}\n"
        response += f"**Port:** {params.get('port', 80)}\n"
        response += f"**SSL:** {'Yes' if params.get('ssl', False) else 'No'}\n"
        response += f"**Command:** `{result.get('command', 'Unknown')}`\n\n"

        # Check execution status
        if result.get("timed_out"):
            return self._format_timeout_response(params.get("timeout", 10), target)

        return_code = result.get("return_code", -1)
        stdout = result.get("stdout", "")
        stderr = result.get("stderr", "")

        # Analyze results
        vulnerabilities = self._parse_nikto_output(stdout)

        # Format summary
        response += "## 📊 Scan Summary\n\n"
        if return_code == 0:
            response += "**Status:** ✅ Completed Successfully\n"
        elif return_code == 1:
            response += "**Status:** ⚠️ Completed with warnings\n"
        else:
            response += "**Status:** ❌ Failed or incomplete\n"

        response += f"**Issues Found:** {len(vulnerabilities)}\n"
        response += f"**Return Code:** {return_code}\n\n"

        # Format vulnerabilities
        if vulnerabilities:
            response += "## 🚨 Security Issues Identified\n\n"

            # Group by severity if available
            high_issues = [
                v
                for v in vulnerabilities
                if v.get("severity", "").lower() in ["high", "critical"]
            ]
            medium_issues = [
                v for v in vulnerabilities if v.get("severity", "").lower() == "medium"
            ]
            low_issues = [
                v
                for v in vulnerabilities
                if v.get("severity", "").lower() in ["low", "info"]
            ]
            other_issues = [
                v
                for v in vulnerabilities
                if v not in high_issues + medium_issues + low_issues
            ]

            # Show high priority issues first
            for category, issues, emoji in [
                ("Critical/High Priority", high_issues, "🔴"),
                ("Medium Priority", medium_issues, "🟡"),
                ("Low/Informational", low_issues, "🟢"),
                ("Other Issues", other_issues, "⚪"),
            ]:
                if issues:
                    response += f"### {emoji} {category} ({len(issues)} issues)\n\n"
                    for i, vuln in enumerate(
                        issues[:10], 1
                    ):  # Limit to 10 per category
                        response += f"**{i}. {vuln.get('title', 'Security Issue')}**\n"
                        if vuln.get("description"):
                            response += f"   - **Description:** {vuln['description']}\n"
                        if vuln.get("uri"):
                            response += f"   - **Location:** {vuln['uri']}\n"
                        if vuln.get("method"):
                            response += f"   - **Method:** {vuln['method']}\n"
                        response += "\n"

                    if len(issues) > 10:
                        response += (
                            f"   ... and {len(issues) - 10} more {category.lower()}\n\n"
                        )

        else:
            response += "## ✅ No Obvious Vulnerabilities Detected\n\n"
            response += "Nikto did not identify any clear security issues, but this doesn't guarantee the target is secure.\n"
            response += "Consider running additional scans or manual testing.\n\n"

        # Include raw output if there were errors or for debugging
        if stderr or return_code != 0:
            response += "## 🔧 Technical Details\n\n"

            if stderr:
                response += "### ⚠️ Warnings/Errors\n\n"
                response += f"```\n{stderr[:1000]}\n```\n\n"
                if len(stderr) > 1000:
                    response += f"... (truncated, {len(stderr)} total characters)\n\n"

            if stdout and not vulnerabilities:
                response += "### 📄 Raw Output\n\n"
                response += f"```\n{stdout[:2000]}\n```\n\n"
                if len(stdout) > 2000:
                    response += f"... (truncated, {len(stdout)} total characters)\n\n"

        # Recommendations
        response += "## 💡 Recommendations\n\n"
        if vulnerabilities:
            response += "1. **Prioritize High/Critical Issues** - Address red-flagged vulnerabilities immediately\n"
            response += "2. **Validate Findings** - Manually verify automated results to avoid false positives\n"
            response += "3. **Apply Security Patches** - Update software and configurations as recommended\n"
            response += "4. **Regular Scanning** - Implement periodic vulnerability assessments\n"
            response += "5. **Defense in Depth** - Combine multiple security controls and monitoring\n"
        else:
            response += "1. **Manual Review** - Perform manual security testing beyond automated scans\n"
            response += "2. **Configuration Review** - Audit web server and application configurations\n"
            response += (
                "3. **Additional Tools** - Use complementary scanners (nuclei, etc.)\n"
            )
            response += "4. **Penetration Testing** - Consider professional security assessment\n"

        return response

    def _parse_nikto_output(self, output: str) -> list:
        """Parse Nikto CSV output into structured format"""
        vulnerabilities = []

        if not output or not output.strip():
            return vulnerabilities

        try:
            # Split into lines and process CSV format
            lines = output.strip().split("\n")

            for line in lines:
                line = line.strip()
                if not line or line.startswith("#") or line.startswith('"host"'):
                    continue

                # Basic CSV parsing (Nikto CSV: host,ip,port,description,method,uri,OSVDB,CVE)
                if "," in line:
                    try:
                        parts = [p.strip().strip('"') for p in line.split(",")]
                        if len(parts) >= 4:
                            vuln = {
                                "title": parts[3]
                                if len(parts) > 3
                                else "Security Issue",
                                "description": parts[3]
                                if len(parts) > 3
                                else "No description",
                                "method": parts[4] if len(parts) > 4 else "Unknown",
                                "uri": parts[5] if len(parts) > 5 else "Unknown",
                                "osvdb": parts[6] if len(parts) > 6 else "",
                                "cve": parts[7] if len(parts) > 7 else "",
                                "severity": "medium",  # Default severity
                            }

                            # Try to determine severity from description
                            desc_lower = vuln["description"].lower()
                            if any(
                                word in desc_lower
                                for word in [
                                    "critical",
                                    "exploit",
                                    "rce",
                                    "sql injection",
                                ]
                            ):
                                vuln["severity"] = "high"
                            elif any(
                                word in desc_lower
                                for word in ["information", "disclosure", "banner"]
                            ):
                                vuln["severity"] = "low"

                            vulnerabilities.append(vuln)

                    except Exception as e:
                        # If CSV parsing fails, treat the whole line as a finding
                        vulnerabilities.append(
                            {
                                "title": "Parse Error",
                                "description": line,
                                "method": "Unknown",
                                "uri": "Unknown",
                                "severity": "medium",
                            }
                        )

        except Exception as e:
            # Fallback: try to extract any obvious findings from raw text
            for line in output.split("\n"):
                line = line.strip()
                if line and not line.startswith("#") and len(line) > 10:
                    vulnerabilities.append(
                        {
                            "title": "Finding",
                            "description": line,
                            "method": "Unknown",
                            "uri": "Unknown",
                            "severity": "medium",
                        }
                    )

        return vulnerabilities

    def is_available(self) -> bool:
        """Check if Nikto is available"""
        try:
            # Check if tool path exists
            if os.path.exists(self.tool_path):
                return True

            # Try executing nikto to check availability
            import subprocess

            if self.tool_path.endswith(".pl"):
                result = subprocess.run(
                    ["perl", self.tool_path, "-Version"],
                    capture_output=True,
                    timeout=10,
                )
            else:
                result = subprocess.run(
                    [self.tool_path, "-Version"], capture_output=True, timeout=10
                )

            return result.returncode == 0

        except Exception:
            return False
