"""
Flask Backend Client for retrieving vulnerability data
Provides async interface to communicate with the existing Flask vulnerability analysis backend
"""

import aiohttp
import asyncio
import logging
from typing import Dict, Any, Optional
from urllib.parse import urljoin
import json

logger = logging.getLogger(__name__)


class FlaskBackendClient:
    """Async HTTP client for Flask backend communication"""

    def __init__(self, base_url: str = "http://localhost:5000"):
        self.base_url = base_url.rstrip("/")
        self.session = None
        self.timeout = aiohttp.ClientTimeout(total=300)  # 5 minutes

    async def _get_session(self) -> aiohttp.ClientSession:
        """Get or create aiohttp session"""
        if self.session is None or self.session.closed:
            self.session = aiohttp.ClientSession(timeout=self.timeout)
        return self.session

    async def get_vulnerability_data(
        self, target: str, scan_type: str = "comprehensive"
    ) -> Dict[str, Any]:
        """
        Retrieve comprehensive vulnerability data from Flask backend MCP endpoint

        Args:
            target: Target domain or IP address
            scan_type: Type of scan (quick, comprehensive, targeted, deep)

        Returns:
            Dictionary containing vulnerability analysis data
        """
        session = await self._get_session()

        try:
            # Use the new MCP-specific endpoint
            url = f"{self.base_url}/mcp/vulnerability-data"
            params = {"target": target, "scan_type": scan_type}

            logger.info(f"Fetching vulnerability data from {url} for target: {target}")

            async with session.get(url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    logger.info(
                        f"Successfully retrieved data for {target}: {data.get('scan_summary', {})}"
                    )
                    return data
                else:
                    error_text = await response.text()
                    logger.error(
                        f"HTTP {response.status} error from Flask backend: {error_text}"
                    )
                    raise Exception(f"HTTP {response.status}: {error_text}")

        except aiohttp.ClientError as e:
            logger.error(f"Network error communicating with Flask backend: {e}")
            raise Exception(f"Network error: {str(e)}")
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON response from Flask backend: {e}")
            raise Exception(f"Invalid response format: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error fetching vulnerability data: {e}")
            raise Exception(f"Backend communication failed: {str(e)}")

    async def health_check(self) -> Dict[str, Any]:
        """
        Check Flask backend health and connectivity

        Returns:
            Dictionary containing health status information
        """
        session = await self._get_session()

        try:
            url = f"{self.base_url}/mcp/health"
            logger.info(f"Performing health check on {url}")

            async with session.get(url) as response:
                if response.status == 200:
                    data = await response.json()
                    logger.info(
                        f"Backend health check successful: {data.get('status')}"
                    )
                    return data
                else:
                    error_text = await response.text()
                    logger.warning(
                        f"Backend health check failed: HTTP {response.status}: {error_text}"
                    )
                    return {
                        "status": "unhealthy",
                        "error": f"HTTP {response.status}: {error_text}",
                        "backend_url": self.base_url,
                    }

        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return {
                "status": "unreachable",
                "error": str(e),
                "backend_url": self.base_url,
            }

    async def get_config(self) -> Dict[str, Any]:
        """Get current Flask client configuration"""
        health_status = await self.health_check()

        return {
            "backend_url": self.base_url,
            "timeout": self.timeout.total,
            "health_status": health_status,
            "endpoints": {
                "vulnerability_data": "/mcp/vulnerability-data",
                "health_check": "/mcp/health",
            },
        }

    async def _poll_scan_results(
        self, scan_id: str, max_attempts: int = 60, interval: int = 10
    ) -> Dict[str, Any]:
        """Poll for async scan results"""
        session = await self._get_session()

        for attempt in range(max_attempts):
            try:
                async with session.get(
                    urljoin(self.base_url, f"/api/scan/{scan_id}/status")
                ) as response:
                    if response.status == 200:
                        data = await response.json()

                        status = data.get("status", "unknown")
                        if status == "completed":
                            return self._normalize_response_data(
                                data.get("results", {})
                            )
                        elif status == "failed":
                            raise Exception(
                                f"Scan failed: {data.get('error', 'Unknown error')}"
                            )
                        elif status in ["running", "pending"]:
                            logger.info(
                                f"Scan {scan_id} still running, attempt {attempt + 1}/{max_attempts}"
                            )
                            await asyncio.sleep(interval)
                            continue
                        else:
                            raise Exception(f"Unknown scan status: {status}")
                    else:
                        error_text = await response.text()
                        raise Exception(
                            f"Status check failed {response.status}: {error_text}"
                        )

            except Exception as e:
                if attempt == max_attempts - 1:
                    raise Exception(
                        f"Scan polling timeout after {max_attempts} attempts: {e}"
                    )
                logger.warning(f"Polling attempt {attempt + 1} failed: {e}")
                await asyncio.sleep(interval)

        raise Exception("Scan polling timeout")

    def _normalize_response_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Normalize and validate response data structure"""
        normalized = {
            "timestamp": data.get("timestamp", "N/A"),
            "target": data.get("target", "Unknown"),
            "scan_type": data.get("scan_type", "unknown"),
            "subdomains": data.get("subdomains", []),
            "services": data.get("services", []),
            "vulnerabilities": data.get("vulnerabilities", []),
            "ssl_issues": data.get("ssl_issues", []),
            "technologies": data.get("technologies", []),
            "ports": data.get("ports", []),
            "dns_records": data.get("dns_records", []),
            "certificates": data.get("certificates", []),
            "geolocation": data.get("geolocation", {}),
            "reputation": data.get("reputation", {}),
            "metadata": {
                "scan_duration": data.get("scan_duration", 0),
                "tools_used": data.get("tools_used", []),
                "confidence_score": data.get("confidence_score", 0.0),
                "completeness": data.get("completeness", "unknown"),
            },
        }

        return normalized

    def _get_mock_data(self, target: str, scan_type: str) -> Dict[str, Any]:
        """Return mock data when backend is unavailable (for testing)"""
        logger.warning(f"Using mock data for {target} due to backend unavailability")

        return {
            "timestamp": "2025-08-13T11:30:00Z",
            "target": target,
            "scan_type": scan_type,
            "subdomains": [
                f"www.{target}",
                f"api.{target}",
                f"admin.{target}",
                f"mail.{target}",
            ],
            "services": [
                {"port": 80, "service": "http", "version": "nginx/1.18.0"},
                {"port": 443, "service": "https", "version": "nginx/1.18.0"},
                {"port": 22, "service": "ssh", "version": "OpenSSH 8.2"},
            ],
            "vulnerabilities": [
                {
                    "id": "CVE-2023-MOCK",
                    "title": "Mock Vulnerability for Testing",
                    "severity": "Medium",
                    "description": "This is mock vulnerability data used when Flask backend is unavailable",
                }
            ],
            "ssl_issues": [],
            "technologies": ["Nginx", "Ubuntu", "OpenSSL"],
            "ports": [22, 80, 443],
            "dns_records": [
                {"type": "A", "value": "192.168.1.1"},
                {"type": "MX", "value": f"mail.{target}"},
            ],
            "certificates": [],
            "geolocation": {"country": "Unknown", "city": "Unknown"},
            "reputation": {"score": 0, "sources": []},
            "metadata": {
                "scan_duration": 0,
                "tools_used": ["mock_scanner"],
                "confidence_score": 0.1,
                "completeness": "mock_data",
            },
        }

    async def get_scan_status(self, scan_id: str) -> Dict[str, Any]:
        """Get status of a running scan"""
        session = await self._get_session()

        try:
            async with session.get(
                urljoin(self.base_url, f"/api/scan/{scan_id}/status")
            ) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    error_text = await response.text()
                    raise Exception(
                        f"Status check failed {response.status}: {error_text}"
                    )
        except Exception as e:
            logger.error(f"Error checking scan status: {e}")
            raise

    async def get_historical_data(self, target: str, limit: int = 10) -> Dict[str, Any]:
        """Get historical vulnerability data for target"""
        session = await self._get_session()

        try:
            params = {"limit": limit}
            async with session.get(
                urljoin(self.base_url, f"/api/history/{target}"), params=params
            ) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    error_text = await response.text()
                    raise Exception(
                        f"History retrieval failed {response.status}: {error_text}"
                    )
        except Exception as e:
            logger.error(f"Error retrieving historical data: {e}")
            raise

    async def start_async_scan(
        self, target: str, scan_type: str = "comprehensive"
    ) -> str:
        """Start an asynchronous scan and return scan ID"""
        session = await self._get_session()

        try:
            request_data = {"target": target, "scan_type": scan_type, "async": True}

            async with session.post(
                urljoin(self.base_url, "/api/scan/async"),
                json=request_data,
                headers={"Content-Type": "application/json"},
            ) as response:
                if response.status in [200, 202]:
                    data = await response.json()
                    return data.get("scan_id")
                else:
                    error_text = await response.text()
                    raise Exception(
                        f"Async scan start failed {response.status}: {error_text}"
                    )
        except Exception as e:
            logger.error(f"Error starting async scan: {e}")
            raise

    async def close(self):
        """Close the HTTP session"""
        if self.session and not self.session.closed:
            await self.session.close()
            logger.info("Flask client session closed")
