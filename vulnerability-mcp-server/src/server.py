"""
Main MCP Server for Vulnerability Analysis
Connects to Flask backend and provides intelligent vulnerability scanning tools
"""

import asyncio
import json
import logging
import os
from typing import Any, Dict, List, Optional
from urllib.parse import urlparse

# MCP Imports
from mcp.server import Server
from mcp.server.models import InitializationOptions
from mcp.server.stdio import stdio_server
from mcp.types import Resource, Tool, TextContent, ImageContent, EmbeddedResource

# Local imports
from .flask_client import FlaskBackendClient
from .tools.nikto import NiktoTool
from .tools.nmap import NmapTool
from .tools.ffuf import FFUFTool
from .tools.nuclei import NucleiTool
from .tools.tool_registry import ToolRegistry
from .analysis.intelligence import VulnerabilityIntelligence
from .analysis.prompts import AnalysisPrompts

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class VulnerabilityMCPServer:
    """Main MCP Server for Vulnerability Analysis"""

    def __init__(self, flask_url: str = "http://localhost:5000"):
        self.server = Server("vulnerability-scanner")
        self.flask_client = FlaskBackendClient(flask_url)
        self.tool_registry = ToolRegistry()
        self.intelligence = VulnerabilityIntelligence()
        self.prompts = AnalysisPrompts()

        # Register available tools
        self._register_tools()

        # Setup MCP handlers
        self._setup_handlers()

    def _register_tools(self):
        """Register all available vulnerability scanning tools"""
        try:
            # Register core tools
            tools_to_register = [
                ("nikto", NiktoTool()),
                ("nmap", NmapTool()),
                ("ffuf", FFUFTool()),
                ("nuclei", NucleiTool()),
            ]

            for tool_name, tool_instance in tools_to_register:
                if tool_instance.is_available():
                    self.tool_registry.register_tool(tool_name, tool_instance)
                    logger.info(f"Registered tool: {tool_name}")
                else:
                    logger.warning(f"Tool {tool_name} not available, skipping")

            logger.info(
                f"Successfully registered {len(self.tool_registry.tools)} tools"
            )

        except Exception as e:
            logger.error(f"Error registering tools: {e}")

    def _setup_handlers(self):
        """Setup MCP server handlers"""

        @self.server.list_resources()
        async def handle_list_resources() -> List[Resource]:
            """List available analysis resources and prompts"""
            return [
                Resource(
                    uri="prompt://vulnerability-analysis",
                    name="Vulnerability Analysis Methodology",
                    description="Comprehensive guide for systematic vulnerability analysis",
                    mimeType="text/plain",
                ),
                Resource(
                    uri="prompt://tool-selection",
                    name="Intelligent Tool Selection Guide",
                    description="AI-driven tool selection based on target reconnaissance",
                    mimeType="text/plain",
                ),
                Resource(
                    uri="prompt://scan-strategy",
                    name="Optimal Scanning Strategy",
                    description="Smart scanning strategy based on target characteristics",
                    mimeType="text/plain",
                ),
                Resource(
                    uri="config://flask-backend",
                    name="Flask Backend Configuration",
                    description="Current Flask backend connection and status",
                    mimeType="application/json",
                ),
                Resource(
                    uri="tools://registry",
                    name="Available Security Tools",
                    description="List of registered and available security tools",
                    mimeType="application/json",
                ),
            ]

        @self.server.read_resource()
        async def handle_read_resource(uri: str) -> str:
            """Read analysis resources and configuration"""
            try:
                if uri == "prompt://vulnerability-analysis":
                    return self.prompts.get_vulnerability_analysis_prompt()
                elif uri == "prompt://tool-selection":
                    return self.prompts.get_tool_selection_prompt()
                elif uri == "prompt://scan-strategy":
                    return self.prompts.get_scan_strategy_prompt()
                elif uri == "config://flask-backend":
                    config_data = await self.flask_client.get_config()
                    return json.dumps(config_data, indent=2)
                elif uri == "tools://registry":
                    tools_info = {
                        "available_tools": list(self.tool_registry.tools.keys()),
                        "tool_details": {
                            name: {
                                "description": tool.get_description(),
                                "available": tool.is_available(),
                            }
                            for name, tool in self.tool_registry.tools.items()
                        },
                        "total_tools": len(self.tool_registry.tools),
                    }
                    return json.dumps(tools_info, indent=2)
                else:
                    raise ValueError(f"Unknown resource URI: {uri}")

            except Exception as e:
                logger.error(f"Error reading resource {uri}: {e}")
                return f"Error reading resource: {str(e)}"

        @self.server.list_tools()
        async def handle_list_tools() -> List[Tool]:
            """List all available vulnerability scanning tools"""
            tools = []

            # Flask backend integration tools
            tools.extend(
                [
                    Tool(
                        name="get_vulnerability_data",
                        description="Retrieve comprehensive vulnerability data from Flask backend",
                        inputSchema={
                            "type": "object",
                            "properties": {
                                "target": {
                                    "type": "string",
                                    "description": "Target domain or IP address",
                                },
                                "scan_type": {
                                    "type": "string",
                                    "enum": [
                                        "quick",
                                        "comprehensive",
                                        "targeted",
                                        "deep",
                                    ],
                                    "description": "Type of vulnerability scan to perform",
                                    "default": "comprehensive",
                                },
                            },
                            "required": ["target"],
                        },
                    ),
                    Tool(
                        name="analyze_flask_data",
                        description="Intelligently analyze Flask backend data to determine optimal scanning strategy",
                        inputSchema={
                            "type": "object",
                            "properties": {
                                "target": {
                                    "type": "string",
                                    "description": "Target domain or IP address",
                                },
                                "flask_data": {
                                    "type": "object",
                                    "description": "Raw data from Flask backend (optional - will fetch if not provided)",
                                },
                            },
                            "required": ["target"],
                        },
                    ),
                    Tool(
                        name="intelligent_vulnerability_scan",
                        description="Perform intelligent vulnerability scanning using AI-driven tool selection and orchestration",
                        inputSchema={
                            "type": "object",
                            "properties": {
                                "target": {
                                    "type": "string",
                                    "description": "Target domain or IP address",
                                },
                                "depth": {
                                    "type": "string",
                                    "enum": [
                                        "surface",
                                        "moderate",
                                        "deep",
                                        "comprehensive",
                                    ],
                                    "description": "Scanning depth and intensity level",
                                    "default": "moderate",
                                },
                                "focus_areas": {
                                    "type": "array",
                                    "items": {"type": "string"},
                                    "description": "Specific vulnerability categories to focus on (optional)",
                                },
                                "exclude_tools": {
                                    "type": "array",
                                    "items": {"type": "string"},
                                    "description": "Tools to exclude from scanning (optional)",
                                },
                            },
                            "required": ["target"],
                        },
                    ),
                ]
            )

            # Add individual tool wrappers
            for tool_name, tool_instance in self.tool_registry.tools.items():
                try:
                    tools.append(
                        Tool(
                            name=f"run_{tool_name}",
                            description=tool_instance.get_description(),
                            inputSchema=tool_instance.get_input_schema(),
                        )
                    )
                except Exception as e:
                    logger.error(f"Error creating tool definition for {tool_name}: {e}")

            return tools

        @self.server.call_tool()
        async def handle_call_tool(
            name: str, arguments: Dict[str, Any]
        ) -> List[TextContent]:
            """Handle tool execution with comprehensive error handling"""
            try:
                logger.info(f"Executing tool: {name} with arguments: {arguments}")

                if name == "get_vulnerability_data":
                    return await self._get_vulnerability_data(arguments)
                elif name == "analyze_flask_data":
                    return await self._analyze_flask_data(arguments)
                elif name == "intelligent_vulnerability_scan":
                    return await self._intelligent_vulnerability_scan(arguments)
                elif name.startswith("run_"):
                    tool_name = name[4:]  # Remove "run_" prefix
                    return await self._run_tool(tool_name, arguments)
                else:
                    raise ValueError(f"Unknown tool: {name}")

            except Exception as e:
                logger.error(f"Tool execution error for {name}: {e}", exc_info=True)
                return [
                    TextContent(
                        type="text",
                        text=f"❌ **Error executing tool {name}**\n\nError: {str(e)}\n\nPlease check the tool configuration and try again.",
                    )
                ]

    async def _get_vulnerability_data(
        self, arguments: Dict[str, Any]
    ) -> List[TextContent]:
        """Get comprehensive vulnerability data from Flask backend"""
        target = arguments["target"]
        scan_type = arguments.get("scan_type", "comprehensive")

        logger.info(
            f"Fetching vulnerability data for {target} (scan_type: {scan_type})"
        )

        try:
            # Validate target
            if not target or len(target.strip()) == 0:
                raise ValueError("Target cannot be empty")

            # Fetch data from Flask backend
            data = await self.flask_client.get_vulnerability_data(target, scan_type)

            # Format comprehensive response
            response_text = self._format_flask_data_response(target, scan_type, data)

            return [TextContent(type="text", text=response_text)]

        except Exception as e:
            error_msg = f"❌ **Error fetching vulnerability data for {target}**\n\n"
            error_msg += f"**Scan Type:** {scan_type}\n"
            error_msg += f"**Error:** {str(e)}\n\n"
            error_msg += "**Troubleshooting:**\n"
            error_msg += "- Verify Flask backend is running and accessible\n"
            error_msg += "- Check target format (domain.com or IP address)\n"
            error_msg += "- Ensure network connectivity\n"

            return [TextContent(type="text", text=error_msg)]

    async def _analyze_flask_data(self, arguments: Dict[str, Any]) -> List[TextContent]:
        """Analyze Flask data to determine optimal scanning strategy"""
        target = arguments["target"]
        flask_data = arguments.get("flask_data")

        try:
            # Fetch data if not provided
            if not flask_data:
                logger.info(f"Fetching Flask data for analysis of {target}")
                flask_data = await self.flask_client.get_vulnerability_data(target)

            # Perform intelligent analysis
            analysis = await self.intelligence.analyze_target_data(target, flask_data)

            # Generate tool recommendations
            recommendations = self.intelligence.generate_tool_recommendations(analysis)

            # Format comprehensive analysis response
            response_text = self._format_analysis_response(
                target, analysis, recommendations
            )

            return [TextContent(type="text", text=response_text)]

        except Exception as e:
            error_msg = f"❌ **Error analyzing data for {target}**\n\n"
            error_msg += f"**Error:** {str(e)}\n\n"
            error_msg += "**Next Steps:**\n"
            error_msg += (
                f"1. Try fetching fresh data: `get_vulnerability_data` for {target}\n"
            )
            error_msg += "2. Check Flask backend connectivity\n"
            error_msg += "3. Verify target accessibility\n"

            return [TextContent(type="text", text=error_msg)]

    async def _intelligent_vulnerability_scan(
        self, arguments: Dict[str, Any]
    ) -> List[TextContent]:
        """Perform intelligent vulnerability scanning with AI orchestration"""
        target = arguments["target"]
        depth = arguments.get("depth", "moderate")
        focus_areas = arguments.get("focus_areas", [])
        exclude_tools = arguments.get("exclude_tools", [])

        results = []
        results.append(f"# 🔍 Intelligent Vulnerability Scan: {target}\n")
        results.append(f"**Scan Depth:** {depth.title()}")
        results.append(
            f"**Focus Areas:** {', '.join(focus_areas) if focus_areas else 'All vulnerability categories'}"
        )
        results.append(
            f"**Excluded Tools:** {', '.join(exclude_tools) if exclude_tools else 'None'}\n"
        )

        try:
            # Phase 1: Intelligence Gathering
            results.append("## 📊 Phase 1: Intelligence Gathering\n")
            results.append(
                "Collecting initial reconnaissance data from Flask backend...\n"
            )

            flask_data = await self.flask_client.get_vulnerability_data(
                target, "comprehensive"
            )

            subdomain_count = len(flask_data.get("subdomains", []))
            service_count = len(flask_data.get("services", []))
            initial_vulns = len(flask_data.get("vulnerabilities", []))

            results.append(f"✅ **Intelligence Summary:**")
            results.append(f"- **Subdomains Discovered:** {subdomain_count}")
            results.append(f"- **Services Detected:** {service_count}")
            results.append(f"- **Initial Vulnerabilities:** {initial_vulns}")
            results.append(
                f"- **Technologies:** {', '.join(flask_data.get('technologies', [])[:5])}"
            )
            results.append("")

            # Phase 2: Analysis & Planning
            results.append("## 🧠 Phase 2: Intelligent Analysis & Planning\n")

            analysis = await self.intelligence.analyze_target_data(target, flask_data)
            recommendations = self.intelligence.generate_tool_recommendations(analysis)

            # Filter recommendations based on available tools and exclusions
            filtered_recommendations = [
                rec
                for rec in recommendations
                if rec["tool"].lower() in self.tool_registry.tools
                and rec["tool"].lower() not in [tool.lower() for tool in exclude_tools]
            ]

            results.append(f"**Target Assessment:**")
            results.append(f"- **Risk Level:** {analysis.get('risk_level', 'Unknown')}")
            results.append(
                f"- **Attack Surface:** {analysis.get('attack_surface', 'Unknown')}"
            )
            results.append(f"- **Recommended Tools:** {len(filtered_recommendations)}")
            results.append("")

            # Phase 3: Tool Execution
            results.append("## ⚡ Phase 3: Vulnerability Scanner Execution\n")

            successful_scans = 0
            total_vulnerabilities = 0

            for i, rec in enumerate(filtered_recommendations, 1):
                tool_name = rec["tool"].lower()

                # Check execution probability and depth requirements
                should_execute = self.intelligence.should_execute_tool(
                    rec, analysis, depth
                )

                if should_execute:
                    results.append(f"### {i}. {rec['tool']} Scanner")
                    results.append(
                        f"**Priority:** {rec['priority']} | **Rationale:** {rec['rationale']}"
                    )
                    results.append("")

                    try:
                        # Execute the tool with appropriate parameters
                        tool_args = {"target": target, **rec.get("arguments", {})}

                        logger.info(f"Executing {tool_name} with args: {tool_args}")

                        tool_result = await self._run_tool(tool_name, tool_args)
                        result_text = (
                            tool_result[0].text if tool_result else "No output returned"
                        )

                        results.append(result_text)
                        results.append("")

                        successful_scans += 1

                        # Extract vulnerability count if possible
                        if "vulnerabilities found" in result_text.lower():
                            # Simple extraction - could be enhanced
                            import re

                            vuln_match = re.search(
                                r"(\d+)\s+vulnerabilities?\s+found", result_text.lower()
                            )
                            if vuln_match:
                                total_vulnerabilities += int(vuln_match.group(1))

                    except Exception as e:
                        results.append(f"❌ **Tool execution failed:** {str(e)}")
                        results.append("")
                        logger.error(f"Tool {tool_name} execution failed: {e}")
                else:
                    results.append(f"### ⏭️ Skipping {rec['tool']}")
                    results.append(
                        f"**Reason:** {rec.get('skip_reason', 'Low probability of actionable results')}"
                    )
                    results.append("")

            # Phase 4: Summary & Next Steps
            results.append("## 📋 Scan Summary & Results\n")
            results.append(f"**Execution Summary:**")
            results.append(f"- **Target:** {target}")
            results.append(f"- **Scan Depth:** {depth}")
            results.append(
                f"- **Tools Executed:** {successful_scans}/{len(filtered_recommendations)}"
            )
            results.append(f"- **Total Vulnerabilities:** {total_vulnerabilities}+")
            results.append(
                f"- **Status:** {'✅ Completed Successfully' if successful_scans > 0 else '⚠️ Limited Execution'}"
            )
            results.append("")

            if successful_scans > 0:
                results.append("**🎯 Key Findings:**")
                results.append(
                    "- Review individual tool outputs above for detailed vulnerability information"
                )
                results.append(
                    "- Correlate findings across different tools for comprehensive assessment"
                )
                results.append(
                    "- Prioritize remediation based on risk levels and business impact"
                )
                results.append("")

                results.append("**📖 Next Steps:**")
                results.append(
                    "1. **Manual Validation:** Verify automated findings with manual testing"
                )
                results.append(
                    "2. **Risk Assessment:** Evaluate business impact of identified vulnerabilities"
                )
                results.append(
                    "3. **Remediation Planning:** Develop timeline and approach for vulnerability fixes"
                )
                results.append(
                    "4. **Documentation:** Create comprehensive security assessment report"
                )
            else:
                results.append("**⚠️ Limited Results:**")
                results.append(
                    "- Consider adjusting scan depth or target specification"
                )
                results.append("- Verify tool configurations and target accessibility")
                results.append("- Manual reconnaissance may be required")

        except Exception as e:
            results.append(f"❌ **Critical Scan Error:** {str(e)}")
            results.append(f"**Recovery Actions:**")
            results.append(f"1. Verify Flask backend connectivity")
            results.append(f"2. Check target specification and accessibility")
            results.append(f"3. Review tool configurations and permissions")
            logger.error(f"Critical error in intelligent scan: {e}", exc_info=True)

        return [TextContent(type="text", text="\n".join(results))]

    async def _run_tool(
        self, tool_name: str, arguments: Dict[str, Any]
    ) -> List[TextContent]:
        """Execute a specific vulnerability scanning tool"""
        if tool_name not in self.tool_registry.tools:
            available_tools = list(self.tool_registry.tools.keys())
            error_msg = f"❌ **Tool '{tool_name}' not available**\n\n"
            error_msg += f"**Available tools:** {', '.join(available_tools) if available_tools else 'None'}\n"
            error_msg += f"**Suggestion:** Check tool installation and configuration"

            return [TextContent(type="text", text=error_msg)]

        try:
            tool = self.tool_registry.tools[tool_name]
            logger.info(f"Executing tool {tool_name} with arguments: {arguments}")

            result = await tool.execute(arguments)
            return [TextContent(type="text", text=result)]

        except Exception as e:
            error_msg = f"❌ **Tool '{tool_name}' execution failed**\n\n"
            error_msg += f"**Error:** {str(e)}\n"
            error_msg += f"**Arguments:** {json.dumps(arguments, indent=2)}\n\n"
            error_msg += f"**Troubleshooting:**\n"
            error_msg += f"- Verify tool is properly installed and accessible\n"
            error_msg += f"- Check argument format and values\n"
            error_msg += f"- Ensure target is reachable and responsive\n"

            logger.error(f"Tool {tool_name} execution error: {e}", exc_info=True)
            return [TextContent(type="text", text=error_msg)]

    def _format_flask_data_response(
        self, target: str, scan_type: str, data: Dict[str, Any]
    ) -> str:
        """Format Flask backend data into comprehensive response"""
        response = f"# 🛡️ Vulnerability Intelligence Report: {target}\n\n"
        response += f"**Scan Type:** {scan_type.title()}\n"
        response += f"**Timestamp:** {data.get('timestamp', 'N/A')}\n\n"

        # Executive Summary
        summary = {
            "subdomains": len(data.get("subdomains", [])),
            "services": len(data.get("services", [])),
            "vulnerabilities": len(data.get("vulnerabilities", [])),
            "ssl_issues": len(data.get("ssl_issues", [])),
            "technologies": data.get("technologies", []),
        }

        response += f"## 📊 Executive Summary\n\n"
        response += f"| Metric | Count |\n"
        response += f"|--------|-------|\n"
        response += f"| Subdomains Discovered | {summary['subdomains']} |\n"
        response += f"| Services Detected | {summary['services']} |\n"
        response += f"| Vulnerabilities Identified | {summary['vulnerabilities']} |\n"
        response += f"| SSL/TLS Issues | {summary['ssl_issues']} |\n"
        response += f"| Technologies Detected | {len(summary['technologies'])} |\n\n"

        # Key Findings
        if summary["vulnerabilities"] > 0:
            response += f"## 🚨 Critical Findings\n\n"
            vulns = data.get("vulnerabilities", [])[:5]  # Top 5
            for i, vuln in enumerate(vulns, 1):
                severity = vuln.get("severity", "Unknown")
                title = vuln.get("title", "Unknown Vulnerability")
                response += f"{i}. **{title}** ({severity})\n"

            if len(data.get("vulnerabilities", [])) > 5:
                response += f"\n... and {len(data.get('vulnerabilities', [])) - 5} more vulnerabilities\n"
            response += "\n"

        # Technology Stack
        if summary["technologies"]:
            response += f"## 🔧 Technology Stack\n\n"
            tech_list = summary["technologies"][:10]  # Top 10
            response += f"{', '.join(tech_list)}\n"
            if len(summary["technologies"]) > 10:
                response += (
                    f"\n... and {len(summary['technologies']) - 10} more technologies\n"
                )
            response += "\n"

        # Next Steps
        response += f"## 🎯 Recommended Next Steps\n\n"
        response += f"1. **Run Intelligence Analysis:** Use `analyze_flask_data` to get tool recommendations\n"
        response += f"2. **Execute Targeted Scan:** Use `intelligent_vulnerability_scan` for comprehensive testing\n"
        response += f"3. **Manual Verification:** Validate critical findings through manual testing\n"
        response += f"4. **Risk Assessment:** Evaluate business impact and prioritize remediation\n\n"

        # Raw data snippet (if requested)
        response += f"## 📄 Raw Data Summary\n\n"
        response += f"```json\n{json.dumps(summary, indent=2)}\n```\n"

        return response

    def _format_analysis_response(
        self,
        target: str,
        analysis: Dict[str, Any],
        recommendations: List[Dict[str, Any]],
    ) -> str:
        """Format intelligent analysis response"""
        response = f"# 🧠 Intelligence Analysis Report: {target}\n\n"

        # Target Assessment
        response += f"## 🎯 Target Assessment\n\n"
        response += f"**Risk Level:** {analysis.get('risk_level', 'Unknown')}\n"
        response += f"**Attack Surface:** {analysis.get('attack_surface', 'Unknown')}\n"
        response += (
            f"**Complexity Score:** {analysis.get('complexity_score', 'N/A')}/10\n"
        )
        response += f"**Technology Stack Diversity:** {len(analysis.get('technologies', []))} technologies\n\n"

        # Attack Vector Analysis
        vectors = analysis.get("attack_vectors", [])
        if vectors:
            response += f"## ⚡ Potential Attack Vectors\n\n"
            for vector in vectors:
                response += f"- **{vector}**\n"
            response += "\n"

        # Tool Recommendations
        response += f"## 🔧 Recommended Security Tools & Strategy\n\n"

        if recommendations:
            for i, rec in enumerate(recommendations, 1):
                priority_emoji = {"high": "🔴", "medium": "🟡", "low": "🟢"}.get(
                    rec["priority"].lower(), "⚪"
                )

                response += f"### {i}. {priority_emoji} {rec['tool']}\n"
                response += f"**Priority:** {rec['priority'].title()}\n"
                response += f"**Rationale:** {rec['rationale']}\n"
                response += (
                    f"**Estimated Value:** {rec.get('estimated_value', 'Medium')}\n"
                )

                if "command" in rec:
                    response += f"**Command:** `{rec['command']}`\n"

                response += "\n"
        else:
            response += "No specific tool recommendations generated.\n\n"

        # Execution Strategy
        response += f"## 📋 Execution Strategy\n\n"
        response += f"**Recommended Approach:**\n"

        high_priority = [r for r in recommendations if r["priority"].lower() == "high"]
        medium_priority = [
            r for r in recommendations if r["priority"].lower() == "medium"
        ]

        if high_priority:
            response += f"1. **High Priority Phase:** Execute {', '.join([r['tool'] for r in high_priority])}\n"
        if medium_priority:
            response += f"2. **Secondary Phase:** Execute {', '.join([r['tool'] for r in medium_priority])}\n"

        response += f"3. **Analysis Phase:** Correlate and analyze all results\n"
        response += (
            f"4. **Validation Phase:** Manual verification of critical findings\n\n"
        )

        # Next Steps
        response += f"## 🚀 Next Steps\n\n"
        response += f"**Immediate Actions:**\n"
        response += f"1. Execute intelligent scan: `intelligent_vulnerability_scan` with target `{target}`\n"
        response += f"2. Choose appropriate scan depth based on risk level\n"
        response += f"3. Focus on high-priority tools first\n\n"

        response += f"**Scan Depth Recommendations:**\n"
        risk_level = analysis.get("risk_level", "medium").lower()
        if risk_level == "high":
            response += f"- **Recommended Depth:** `comprehensive` or `deep`\n"
        elif risk_level == "medium":
            response += f"- **Recommended Depth:** `moderate`\n"
        else:
            response += f"- **Recommended Depth:** `surface` or `moderate`\n"

        return response

    async def cleanup(self):
        """Cleanup resources"""
        try:
            await self.flask_client.close()
            logger.info("MCP Server cleanup completed")
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")


async def main():
    """Main entry point for MCP Server"""
    try:
        # Get Flask backend URL from environment or use default
        flask_url = os.getenv("FLASK_BACKEND_URL", "http://localhost:5000")

        # Create server instance
        server_instance = VulnerabilityMCPServer(flask_url)

        logger.info(f"Starting Vulnerability Analysis MCP Server...")
        logger.info(f"Flask Backend: {flask_url}")
        logger.info(
            f"Available Tools: {list(server_instance.tool_registry.tools.keys())}"
        )

        # Run the server with the correct stdio pattern

        # Create empty notification options
        class NotificationOptions:
            def __init__(self):
                self.resources_changed = False
                self.tools_changed = False
                self.prompts_changed = False

        notification_opts = NotificationOptions()
        experimental_caps = {}

        # Get server capabilities
        capabilities = server_instance.server.get_capabilities(
            notification_options=notification_opts,
            experimental_capabilities=experimental_caps,
        )

        # Run server with proper stdio handling
        async with stdio_server() as (read_stream, write_stream):
            await server_instance.server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="vulnerability-scanner",
                    server_version="1.0.0",
                    capabilities=capabilities,
                ),
            )

    except KeyboardInterrupt:
        logger.info("Server interrupted by user")
    except Exception as e:
        logger.error(f"Server error: {e}", exc_info=True)
    finally:
        if "server_instance" in locals():
            await server_instance.cleanup()


if __name__ == "__main__":
    asyncio.run(main())
