"""
Analysis Prompts and Methodology Guides
Provides intelligent prompts and analysis guidance for vulnerability assessment
"""

from typing import Dict, Any, List
from datetime import datetime


class AnalysisPrompts:
    """Provides analysis prompts and methodology guidance"""

    def __init__(self):
        self.tool_methodologies = self._initialize_tool_methodologies()
        self.vulnerability_categories = self._initialize_vulnerability_categories()
        self.analysis_frameworks = self._initialize_analysis_frameworks()

    def _initialize_tool_methodologies(self) -> Dict[str, Dict[str, Any]]:
        """Initialize methodologies for each tool"""
        return {
            "nmap": {
                "description": "Network Discovery and Port Scanning",
                "methodology": [
                    "1. Host Discovery - Identify live hosts on the network",
                    "2. Port Scanning - Discover open ports and services",
                    "3. Service Detection - Identify service versions and details",
                    "4. OS Detection - Fingerprint operating systems",
                    "5. Script Scanning - Run NSE scripts for additional information",
                ],
                "best_practices": [
                    "Start with ping sweep to identify live hosts",
                    "Use SYN scan (-sS) for stealth when possible",
                    "Enable service detection (-sV) for accurate results",
                    "Use appropriate timing (-T3 for balanced performance)",
                    "Consider script scanning for additional intelligence",
                ],
                "common_findings": [
                    "Open ports that should be filtered",
                    "Unnecessary services running",
                    "Default service banners revealing versions",
                    "Services with known vulnerabilities",
                    "Misconfigured firewall rules",
                ],
            },
            "nuclei": {
                "description": "Fast Vulnerability Scanning with Templates",
                "methodology": [
                    "1. Template Selection - Choose appropriate templates for target",
                    "2. Severity Filtering - Focus on medium+ severity issues",
                    "3. Technology Detection - Identify frameworks and CMS",
                    "4. CVE Scanning - Check for known vulnerabilities",
                    "5. Configuration Analysis - Detect misconfigurations",
                ],
                "best_practices": [
                    "Use community templates for comprehensive coverage",
                    "Filter by severity to reduce noise",
                    "Adjust concurrency based on target capacity",
                    "Verify findings manually to avoid false positives",
                    "Update templates regularly for latest vulnerabilities",
                ],
                "common_findings": [
                    "Known CVE vulnerabilities",
                    "Exposed admin panels and interfaces",
                    "Default credentials and configurations",
                    "Information disclosure vulnerabilities",
                    "Technology-specific misconfigurations",
                ],
            },
            "nikto": {
                "description": "Comprehensive Web Server Vulnerability Scanning",
                "methodology": [
                    "1. Server Fingerprinting - Identify web server and version",
                    "2. Dangerous Files - Check for risky files and directories",
                    "3. CGI Scanning - Test for CGI vulnerabilities",
                    "4. Plugin Detection - Identify installed plugins/modules",
                    "5. Configuration Analysis - Check server configurations",
                ],
                "best_practices": [
                    "Use appropriate User-Agent to avoid blocking",
                    "Set reasonable timeouts to avoid hanging",
                    "Review all findings manually due to high false positive rate",
                    "Focus on server configuration and dangerous files",
                    "Combine with other tools for comprehensive assessment",
                ],
                "common_findings": [
                    "Outdated software versions with known vulnerabilities",
                    "Dangerous files like backup files and config files",
                    "Default installation files and directories",
                    "Information leakage through server headers",
                    "Misconfigured server settings",
                ],
            },
            "ffuf": {
                "description": "Web Application Content Discovery and Fuzzing",
                "methodology": [
                    "1. Directory Discovery - Find hidden directories and paths",
                    "2. File Discovery - Locate sensitive files and backups",
                    "3. Parameter Fuzzing - Discover hidden parameters",
                    "4. Subdomain Discovery - Find additional subdomains",
                    "5. Extension Testing - Check for files with various extensions",
                ],
                "best_practices": [
                    "Use appropriate wordlists for the target technology",
                    "Filter out common false positives (404, empty responses)",
                    "Adjust threading based on target capacity",
                    "Follow up on interesting findings manually",
                    "Use multiple wordlists for comprehensive coverage",
                ],
                "common_findings": [
                    "Hidden admin panels and sensitive directories",
                    "Backup files containing sensitive information",
                    "Development and testing files left in production",
                    "API endpoints and documentation",
                    "Configuration files with credentials",
                ],
            },
        }

    def _initialize_vulnerability_categories(self) -> Dict[str, Dict[str, Any]]:
        """Initialize vulnerability categories and their characteristics"""
        return {
            "injection": {
                "description": "Injection vulnerabilities (SQL, XSS, Command Injection, etc.)",
                "severity": "Critical/High",
                "impact": "Data compromise, system takeover, information disclosure",
                "detection_methods": [
                    "Dynamic testing",
                    "Code review",
                    "Automated scanning",
                ],
                "common_tools": ["nuclei", "nikto"],
                "validation_steps": [
                    "Confirm injection point exists",
                    "Test with safe payloads first",
                    "Verify actual exploitation potential",
                    "Document proof of concept",
                ],
            },
            "broken_authentication": {
                "description": "Authentication and session management flaws",
                "severity": "High",
                "impact": "Account takeover, privilege escalation, data access",
                "detection_methods": [
                    "Manual testing",
                    "Automated scanning",
                    "Code review",
                ],
                "common_tools": ["nikto", "nuclei"],
                "validation_steps": [
                    "Test authentication mechanisms",
                    "Check session management",
                    "Verify password policies",
                    "Test multi-factor authentication bypasses",
                ],
            },
            "sensitive_data_exposure": {
                "description": "Inadequate protection of sensitive information",
                "severity": "Medium/High",
                "impact": "Information disclosure, privacy violations, compliance issues",
                "detection_methods": [
                    "Content discovery",
                    "Configuration review",
                    "Traffic analysis",
                ],
                "common_tools": ["ffuf", "nikto", "nuclei"],
                "validation_steps": [
                    "Identify what data is exposed",
                    "Assess sensitivity level",
                    "Check encryption in transit and at rest",
                    "Verify access controls",
                ],
            },
            "security_misconfiguration": {
                "description": "Insecure default configurations and settings",
                "severity": "Medium",
                "impact": "Information disclosure, service compromise, attack surface expansion",
                "detection_methods": [
                    "Configuration scanning",
                    "Banner grabbing",
                    "Service enumeration",
                ],
                "common_tools": ["nmap", "nuclei", "nikto"],
                "validation_steps": [
                    "Document configuration issues",
                    "Assess potential impact",
                    "Verify configuration against security baselines",
                    "Check for hardening opportunities",
                ],
            },
            "broken_access_control": {
                "description": "Inadequate access controls and authorization",
                "severity": "High",
                "impact": "Unauthorized access, privilege escalation, data manipulation",
                "detection_methods": [
                    "Manual testing",
                    "Automated scanning",
                    "Role-based testing",
                ],
                "common_tools": ["ffuf", "nuclei"],
                "validation_steps": [
                    "Map access control mechanisms",
                    "Test horizontal and vertical privilege escalation",
                    "Verify business logic enforcement",
                    "Check administrative interface protection",
                ],
            },
        }

    def _initialize_analysis_frameworks(self) -> Dict[str, Dict[str, Any]]:
        """Initialize analysis frameworks and methodologies"""
        return {
            "owasp_top10": {
                "name": "OWASP Top 10",
                "description": "Most critical web application security risks",
                "categories": [
                    "A01:2021 – Broken Access Control",
                    "A02:2021 – Cryptographic Failures",
                    "A03:2021 – Injection",
                    "A04:2021 – Insecure Design",
                    "A05:2021 – Security Misconfiguration",
                    "A06:2021 – Vulnerable and Outdated Components",
                    "A07:2021 – Identification and Authentication Failures",
                    "A08:2021 – Software and Data Integrity Failures",
                    "A09:2021 – Security Logging and Monitoring Failures",
                    "A10:2021 – Server-Side Request Forgery (SSRF)",
                ],
                "tools_mapping": {
                    "nuclei": ["A01", "A02", "A03", "A05", "A06", "A07", "A10"],
                    "nikto": ["A05", "A06", "A09"],
                    "ffuf": ["A01", "A05"],
                    "nmap": ["A05", "A06"],
                },
            },
            "nist_framework": {
                "name": "NIST Cybersecurity Framework",
                "description": "Comprehensive cybersecurity assessment framework",
                "categories": [
                    "Identify - Asset management and risk assessment",
                    "Protect - Access controls and protective technology",
                    "Detect - Continuous monitoring and detection processes",
                    "Respond - Response planning and incident management",
                    "Recover - Recovery planning and resilience",
                ],
                "tools_mapping": {
                    "nmap": ["Identify"],
                    "nuclei": ["Identify", "Detect"],
                    "nikto": ["Identify", "Detect"],
                    "ffuf": ["Identify"],
                },
            },
        }

    def generate_pre_assessment_prompt(
        self, target: str, tools: List[str], context: Dict[str, Any] = None
    ) -> str:
        """Generate comprehensive pre-assessment analysis prompt"""

        prompt = "# 🎯 Vulnerability Assessment Analysis Prompt\n\n"
        prompt += f"**Assessment Target:** {target}\n"
        prompt += f"**Planned Tools:** {', '.join(tools)}\n"
        prompt += (
            f"**Assessment Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        )

        # Context analysis
        if context:
            prompt += "## 📋 Assessment Context\n\n"
            for key, value in context.items():
                prompt += f"**{key.replace('_', ' ').title()}:** {value}\n"
            prompt += "\n"

        # Tool methodologies
        prompt += "## 🛠️ Tool Methodologies\n\n"
        for tool in tools:
            if tool in self.tool_methodologies:
                methodology = self.tool_methodologies[tool]
                prompt += f"### {tool.upper()}: {methodology['description']}\n\n"

                prompt += "**Methodology:**\n"
                for step in methodology["methodology"]:
                    prompt += f"- {step}\n"
                prompt += "\n"

                prompt += "**Best Practices:**\n"
                for practice in methodology["best_practices"]:
                    prompt += f"- ✅ {practice}\n"
                prompt += "\n"

                prompt += "**Common Findings to Look For:**\n"
                for finding in methodology["common_findings"]:
                    prompt += f"- 🔍 {finding}\n"
                prompt += "\n"

        # Analysis frameworks
        prompt += "## 📊 Analysis Frameworks\n\n"

        # OWASP Top 10 mapping
        owasp = self.analysis_frameworks["owasp_top10"]
        prompt += f"### {owasp['name']}\n\n"
        prompt += f"{owasp['description']}\n\n"

        for tool in tools:
            if tool in owasp["tools_mapping"]:
                categories = owasp["tools_mapping"][tool]
                prompt += f"**{tool.upper()} addresses:** {', '.join(categories)}\n"
        prompt += "\n"

        # Vulnerability categories
        prompt += "## 🚨 Key Vulnerability Categories to Assess\n\n"

        relevant_categories = self._get_relevant_categories(tools)
        for category_name in relevant_categories:
            category = self.vulnerability_categories[category_name]
            prompt += f"### {category_name.replace('_', ' ').title()}\n\n"
            prompt += f"**Description:** {category['description']}\n"
            prompt += f"**Severity:** {category['severity']}\n"
            prompt += f"**Impact:** {category['impact']}\n"
            prompt += f"**Detection Tools:** {', '.join(category['common_tools'])}\n\n"

            prompt += "**Validation Steps:**\n"
            for step in category["validation_steps"]:
                prompt += f"- 🔬 {step}\n"
            prompt += "\n"

        # Assessment checklist
        prompt += "## ✅ Assessment Checklist\n\n"
        prompt += "**Pre-Assessment:**\n"
        prompt += "- [ ] Target scope clearly defined\n"
        prompt += "- [ ] Authorization obtained\n"
        prompt += "- [ ] Tools configured and tested\n"
        prompt += "- [ ] Backup and logging enabled\n\n"

        prompt += "**During Assessment:**\n"
        prompt += "- [ ] Start with reconnaissance (nmap)\n"
        prompt += "- [ ] Proceed with vulnerability scanning (nuclei)\n"
        prompt += "- [ ] Perform content discovery (ffuf)\n"
        prompt += "- [ ] Conduct comprehensive scanning (nikto)\n"
        prompt += "- [ ] Document all findings with evidence\n"
        prompt += "- [ ] Validate critical findings manually\n\n"

        prompt += "**Post-Assessment:**\n"
        prompt += "- [ ] Categorize findings by severity\n"
        prompt += "- [ ] Cross-reference with security frameworks\n"
        prompt += "- [ ] Prepare comprehensive report\n"
        prompt += "- [ ] Provide remediation recommendations\n\n"

        return prompt

    def generate_post_assessment_prompt(
        self, results: Dict[str, Any], target: str
    ) -> str:
        """Generate comprehensive post-assessment analysis prompt"""

        prompt = "# 📊 Post-Assessment Analysis Prompt\n\n"
        prompt += f"**Target Assessed:** {target}\n"
        prompt += f"**Analysis Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        prompt += f"**Tools Used:** {', '.join(results.keys())}\n\n"

        # Results summary
        prompt += "## 🔍 Assessment Results Summary\n\n"

        total_findings = 0
        critical_findings = 0

        for tool_name, result in results.items():
            findings_count = self._count_findings(result)
            critical_count = self._count_critical_findings(result)

            total_findings += findings_count
            critical_findings += critical_count

            prompt += f"**{tool_name.upper()}:**\n"
            prompt += f"- Total Findings: {findings_count}\n"
            prompt += f"- Critical/High: {critical_count}\n"
            prompt += f"- Status: {'✅ Completed' if findings_count >= 0 else '❌ Failed'}\n\n"

        prompt += f"**Overall Summary:**\n"
        prompt += f"- **Total Findings:** {total_findings}\n"
        prompt += f"- **Critical/High Severity:** {critical_findings}\n"
        prompt += f"- **Risk Level:** {self._assess_overall_risk(critical_findings, total_findings)}\n\n"

        # Detailed analysis by framework
        prompt += "## 📋 Framework-Based Analysis\n\n"

        # OWASP Top 10 analysis
        prompt += "### OWASP Top 10 Coverage\n\n"
        owasp_coverage = self._analyze_owasp_coverage(results)
        for category, findings in owasp_coverage.items():
            status = "🔴 FOUND" if findings else "🟢 CLEAR"
            prompt += f"- **{category}:** {status}\n"
        prompt += "\n"

        # Vulnerability category analysis
        prompt += "### Vulnerability Categories Detected\n\n"
        detected_categories = self._categorize_findings(results)
        for category, details in detected_categories.items():
            prompt += f"**{category.replace('_', ' ').title()}:**\n"
            prompt += f"- Count: {details['count']}\n"
            prompt += f"- Severity: {details['severity']}\n"
            prompt += f"- Tools: {', '.join(details['tools'])}\n\n"

        # Remediation roadmap
        prompt += "## 🛠️ Remediation Roadmap\n\n"

        if critical_findings > 0:
            prompt += "### 🚨 IMMEDIATE ACTION REQUIRED\n\n"
            prompt += (
                f"**{critical_findings} critical/high severity issues identified**\n\n"
            )
            prompt += "**Priority 1 Actions:**\n"
            prompt += "- [ ] Address all critical vulnerabilities immediately\n"
            prompt += "- [ ] Implement temporary mitigations if patches unavailable\n"
            prompt += "- [ ] Monitor for active exploitation attempts\n"
            prompt += "- [ ] Notify relevant stakeholders and security teams\n\n"

        prompt += "### 📅 Short-term Remediation (1-2 weeks)\n\n"
        prompt += "- [ ] Apply security patches for identified vulnerabilities\n"
        prompt += "- [ ] Fix configuration misconfigurations\n"
        prompt += "- [ ] Remove unnecessary services and files\n"
        prompt += "- [ ] Implement additional access controls\n\n"

        prompt += "### 📅 Medium-term Improvements (1-3 months)\n\n"
        prompt += "- [ ] Conduct security configuration hardening\n"
        prompt += "- [ ] Implement security monitoring and logging\n"
        prompt += "- [ ] Establish vulnerability management process\n"
        prompt += "- [ ] Provide security awareness training\n\n"

        prompt += "### 📅 Long-term Security Program (3+ months)\n\n"
        prompt += "- [ ] Establish regular security assessments\n"
        prompt += "- [ ] Implement DevSecOps practices\n"
        prompt += "- [ ] Create incident response procedures\n"
        prompt += "- [ ] Build security culture and governance\n\n"

        # Validation and testing
        prompt += "## 🔬 Findings Validation Guide\n\n"
        prompt += "**Manual Validation Steps:**\n\n"

        for tool_name, result in results.items():
            if self._has_findings(result):
                prompt += f"### {tool_name.upper()} Findings\n\n"
                validation_steps = self._get_validation_steps(tool_name)
                for step in validation_steps:
                    prompt += f"- [ ] {step}\n"
                prompt += "\n"

        # Monitoring recommendations
        prompt += "## 📡 Continuous Monitoring Recommendations\n\n"
        prompt += "**Implement the following monitoring capabilities:**\n\n"
        prompt += "- [ ] **Vulnerability Scanning:** Regular automated scans\n"
        prompt += "- [ ] **Configuration Monitoring:** Track configuration changes\n"
        prompt += "- [ ] **Access Logging:** Monitor authentication and authorization\n"
        prompt += "- [ ] **Network Monitoring:** Monitor network traffic patterns\n"
        prompt += "- [ ] **File Integrity:** Monitor critical file changes\n"
        prompt += "- [ ] **Security Information and Event Management (SIEM)**\n\n"

        # Compliance mapping
        prompt += "## 📜 Compliance and Standards Mapping\n\n"

        compliance_gaps = self._identify_compliance_gaps(results)
        if compliance_gaps:
            prompt += "**Identified Compliance Gaps:**\n\n"
            for standard, gaps in compliance_gaps.items():
                prompt += f"### {standard}\n\n"
                for gap in gaps:
                    prompt += f"- ⚠️ {gap}\n"
                prompt += "\n"

        return prompt

    def _get_relevant_categories(self, tools: List[str]) -> List[str]:
        """Get vulnerability categories relevant to the selected tools"""
        relevant = set()

        for tool in tools:
            for category_name, category in self.vulnerability_categories.items():
                if tool in category.get("common_tools", []):
                    relevant.add(category_name)

        return list(relevant)

    def _count_findings(self, result: Dict[str, Any]) -> int:
        """Count total findings in a tool result"""
        # Simplified counting logic - would need actual result parsing
        result_str = str(result).lower()

        count = 0
        finding_keywords = [
            "vulnerability",
            "finding",
            "issue",
            "discovered",
            "detected",
        ]

        for keyword in finding_keywords:
            count += result_str.count(keyword)

        return min(count, 50)  # Cap to avoid inflated counts

    def _count_critical_findings(self, result: Dict[str, Any]) -> int:
        """Count critical/high severity findings"""
        result_str = str(result).lower()

        count = 0
        critical_keywords = ["critical", "high", "severe", "rce", "sql injection"]

        for keyword in critical_keywords:
            count += result_str.count(keyword)

        return min(count, 20)  # Cap to avoid inflated counts

    def _assess_overall_risk(self, critical_findings: int, total_findings: int) -> str:
        """Assess overall risk level"""
        if critical_findings >= 5:
            return "🔴 CRITICAL"
        elif critical_findings >= 2:
            return "🟠 HIGH"
        elif total_findings >= 10:
            return "🟡 MEDIUM"
        elif total_findings >= 1:
            return "🟢 LOW"
        else:
            return "⚪ MINIMAL"

    def _analyze_owasp_coverage(self, results: Dict[str, Any]) -> Dict[str, bool]:
        """Analyze OWASP Top 10 coverage from results"""
        owasp_categories = [
            "A01:2021 – Broken Access Control",
            "A02:2021 – Cryptographic Failures",
            "A03:2021 – Injection",
            "A04:2021 – Insecure Design",
            "A05:2021 – Security Misconfiguration",
            "A06:2021 – Vulnerable and Outdated Components",
            "A07:2021 – Identification and Authentication Failures",
            "A08:2021 – Software and Data Integrity Failures",
            "A09:2021 – Security Logging and Monitoring Failures",
            "A10:2021 – Server-Side Request Forgery (SSRF)",
        ]

        coverage = {}
        for category in owasp_categories:
            # Simplified detection - would need more sophisticated analysis
            coverage[category] = self._detect_owasp_category(category, results)

        return coverage

    def _detect_owasp_category(self, category: str, results: Dict[str, Any]) -> bool:
        """Detect if a specific OWASP category is present in results"""
        result_text = str(results).lower()

        # Simple keyword matching - would need more sophisticated logic
        category_keywords = {
            "A01": ["access control", "authorization", "privilege"],
            "A02": ["encryption", "crypto", "ssl", "tls"],
            "A03": ["injection", "sql", "xss", "command injection"],
            "A04": ["insecure design", "business logic"],
            "A05": ["misconfiguration", "default", "configuration"],
            "A06": ["outdated", "vulnerable component", "cve"],
            "A07": ["authentication", "session", "login"],
            "A08": ["integrity", "deserialization"],
            "A09": ["logging", "monitoring"],
            "A10": ["ssrf", "server-side request forgery"],
        }

        category_code = category[:3]
        keywords = category_keywords.get(category_code, [])

        return any(keyword in result_text for keyword in keywords)

    def _categorize_findings(
        self, results: Dict[str, Any]
    ) -> Dict[str, Dict[str, Any]]:
        """Categorize findings by vulnerability type"""
        categories = {}

        for category_name, category_info in self.vulnerability_categories.items():
            count = 0
            tools_found = []

            for tool_name, result in results.items():
                if tool_name in category_info.get("common_tools", []):
                    if self._has_category_findings(result, category_name):
                        count += 1
                        tools_found.append(tool_name)

            if count > 0:
                categories[category_name] = {
                    "count": count,
                    "severity": category_info["severity"],
                    "tools": tools_found,
                }

        return categories

    def _has_category_findings(self, result: Dict[str, Any], category: str) -> bool:
        """Check if result has findings for a specific category"""
        # Simplified logic - would need actual result parsing
        result_str = str(result).lower()

        category_indicators = {
            "injection": ["injection", "sql", "xss", "command"],
            "broken_authentication": ["authentication", "login", "session"],
            "sensitive_data_exposure": ["exposure", "disclosure", "sensitive"],
            "security_misconfiguration": ["misconfiguration", "default", "config"],
            "broken_access_control": ["access control", "authorization", "privilege"],
        }

        indicators = category_indicators.get(category, [])
        return any(indicator in result_str for indicator in indicators)

    def _has_findings(self, result: Dict[str, Any]) -> bool:
        """Check if a result has any findings"""
        return self._count_findings(result) > 0

    def _get_validation_steps(self, tool_name: str) -> List[str]:
        """Get validation steps for a specific tool"""
        validation_steps = {
            "nmap": [
                "Verify open ports are actually accessible",
                "Confirm service versions through manual connection",
                "Validate OS detection through additional methods",
            ],
            "nuclei": [
                "Manually reproduce vulnerability conditions",
                "Verify CVE applicability to detected versions",
                "Test exploit feasibility and impact",
            ],
            "nikto": [
                "Manually browse to identified dangerous files",
                "Verify server configurations through direct testing",
                "Confirm information disclosure through manual inspection",
            ],
            "ffuf": [
                "Manually access discovered directories and files",
                "Verify content sensitivity and business impact",
                "Test access controls on discovered resources",
            ],
        }

        return validation_steps.get(
            tool_name, ["Manually verify all automated findings"]
        )

    def _identify_compliance_gaps(
        self, results: Dict[str, Any]
    ) -> Dict[str, List[str]]:
        """Identify compliance gaps based on findings"""
        gaps = {}

        # Simplified compliance gap identification
        if self._has_encryption_issues(results):
            gaps["PCI DSS"] = [
                "Insufficient encryption controls",
                "Weak SSL/TLS configuration",
            ]

        if self._has_access_control_issues(results):
            gaps["SOX"] = ["Inadequate access controls", "Insufficient audit logging"]

        if self._has_data_exposure_issues(results):
            gaps["GDPR"] = [
                "Potential personal data exposure",
                "Inadequate data protection",
            ]

        return gaps

    def _has_encryption_issues(self, results: Dict[str, Any]) -> bool:
        """Check for encryption-related issues"""
        result_str = str(results).lower()
        return any(
            term in result_str for term in ["ssl", "tls", "encryption", "crypto"]
        )

    def _has_access_control_issues(self, results: Dict[str, Any]) -> bool:
        """Check for access control issues"""
        result_str = str(results).lower()
        return any(
            term in result_str for term in ["access", "authentication", "authorization"]
        )

    def _has_data_exposure_issues(self, results: Dict[str, Any]) -> bool:
        """Check for data exposure issues"""
        result_str = str(results).lower()
        return any(
            term in result_str
            for term in ["exposure", "disclosure", "sensitive", "data"]
        )
