"""
Tool Registry for managing vulnerability scanning tools
Provides centralized registration and management of security tools
"""

import logging
from typing import Dict, List, Optional, Any
from .base_tool import BaseTool

# Import all tool implementations
from .nikto import NiktoTool
from .nmap import NmapTool
from .nuclei import NucleiTool
from .ffuf import FFUFTool

logger = logging.getLogger(__name__)


class ToolRegistry:
    """Registry for managing vulnerability scanning tools"""

    def __init__(self):
        self.tools: Dict[str, BaseTool] = {}
        self._tool_metadata: Dict[str, Dict[str, Any]] = {}
        self._initialize_default_tools()

    def _initialize_default_tools(self) -> None:
        """Initialize and register all default security tools"""
        default_tools = [
            ("nikto", NiktoTool()),
            ("nmap", NmapTool()),
            ("nuclei", NucleiTool()),
            ("ffuf", FFUFTool()),
        ]

        for name, tool_instance in default_tools:
            try:
                self.register_tool(name, tool_instance)
            except Exception as e:
                logger.warning(f"Failed to initialize tool {name}: {e}")

    def register_tool(self, name: str, tool_instance: BaseTool) -> bool:
        """
        Register a new tool in the registry

        Args:
            name: Unique tool name/identifier
            tool_instance: Instance of tool class inheriting from BaseTool

        Returns:
            bool: True if registration successful, False otherwise
        """
        try:
            if not isinstance(tool_instance, BaseTool):
                logger.error(f"Tool {name} must inherit from BaseTool")
                return False

            if name in self.tools:
                logger.warning(f"Tool {name} already registered, replacing...")

            # Check if tool is available
            if not tool_instance.is_available():
                logger.warning(f"Tool {name} registered but not currently available")

            self.tools[name] = tool_instance

            # Store metadata
            self._tool_metadata[name] = {
                "description": tool_instance.get_description(),
                "available": tool_instance.is_available(),
                "class_name": tool_instance.__class__.__name__,
                "timeout": getattr(tool_instance, "timeout", 300),
            }

            logger.info(f"Successfully registered tool: {name}")
            return True

        except Exception as e:
            logger.error(f"Failed to register tool {name}: {e}")
            return False

    def unregister_tool(self, name: str) -> bool:
        """
        Unregister a tool from the registry

        Args:
            name: Tool name to remove

        Returns:
            bool: True if unregistration successful, False otherwise
        """
        try:
            if name in self.tools:
                del self.tools[name]
                if name in self._tool_metadata:
                    del self._tool_metadata[name]
                logger.info(f"Unregistered tool: {name}")
                return True
            else:
                logger.warning(f"Tool {name} not found in registry")
                return False
        except Exception as e:
            logger.error(f"Failed to unregister tool {name}: {e}")
            return False

    def get_tool(self, name: str) -> Optional[BaseTool]:
        """
        Get tool instance by name

        Args:
            name: Tool name

        Returns:
            BaseTool instance or None if not found
        """
        return self.tools.get(name)

    def list_tools(self) -> List[str]:
        """
        Get list of registered tool names

        Returns:
            List of tool names
        """
        return list(self.tools.keys())

    def list_available_tools(self) -> List[str]:
        """
        Get list of available (working) tool names

        Returns:
            List of available tool names
        """
        available = []
        for name, tool in self.tools.items():
            try:
                if tool.is_available():
                    available.append(name)
            except Exception as e:
                logger.error(f"Error checking availability for {name}: {e}")

        return available

    def get_tool_info(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get detailed information about a tool

        Args:
            name: Tool name

        Returns:
            Dictionary with tool information or None if not found
        """
        if name not in self.tools:
            return None

        tool = self.tools[name]
        metadata = self._tool_metadata.get(name, {})

        return {
            "name": name,
            "description": tool.get_description(),
            "available": tool.is_available(),
            "class_name": metadata.get("class_name", "Unknown"),
            "timeout": metadata.get("timeout", 300),
            "input_schema": tool.get_input_schema(),
        }

    def get_all_tools_info(self) -> Dict[str, Dict[str, Any]]:
        """
        Get information about all registered tools

        Returns:
            Dictionary mapping tool names to their information
        """
        all_info = {}
        for name in self.tools.keys():
            tool_info = self.get_tool_info(name)
            if tool_info:
                all_info[name] = tool_info

        return all_info

    def refresh_availability(self) -> Dict[str, bool]:
        """
        Refresh availability status for all tools

        Returns:
            Dictionary mapping tool names to availability status
        """
        availability = {}

        for name, tool in self.tools.items():
            try:
                available = tool.is_available()
                availability[name] = available

                # Update metadata
                if name in self._tool_metadata:
                    self._tool_metadata[name]["available"] = available

                logger.debug(
                    f"Tool {name}: {'Available' if available else 'Not Available'}"
                )

            except Exception as e:
                logger.error(f"Error checking availability for {name}: {e}")
                availability[name] = False

        return availability

    def get_tools_by_category(self, category: str) -> List[str]:
        """
        Get tools filtered by category (based on tool name patterns)

        Args:
            category: Category name (e.g., 'web', 'network', 'vulnerability')

        Returns:
            List of tool names matching the category
        """
        category_mappings = {
            "web": ["nikto", "ffuf", "whatweb", "wpscan"],
            "network": ["nmap", "masscan", "dnsx", "httpx"],
            "vulnerability": ["nuclei", "nikto", "openvas"],
            "subdomain": ["subfinder", "amass", "dnsx"],
            "ssl": ["testssl", "sslscan"],
            "discovery": ["subfinder", "amass", "dnsx", "httpx"],
        }

        category_tools = category_mappings.get(category.lower(), [])
        return [name for name in category_tools if name in self.tools]

    def execute_tool(self, name: str, params: Dict[str, Any]) -> Optional[str]:
        """
        Execute a registered tool with parameters

        Args:
            name: Tool name
            params: Tool parameters

        Returns:
            Tool execution result or None if tool not found
        """
        tool = self.get_tool(name)
        if not tool:
            logger.error(f"Tool {name} not found in registry")
            return None

        try:
            # Note: This is a sync method, async execution should be handled at higher level
            logger.warning(f"Sync execution of {name} - consider using async execution")
            import asyncio

            return asyncio.run(tool.execute(params))
        except Exception as e:
            logger.error(f"Error executing tool {name}: {e}")
            return f"Error executing {name}: {str(e)}"

    def get_registry_stats(self) -> Dict[str, Any]:
        """
        Get statistics about the tool registry

        Returns:
            Dictionary with registry statistics
        """
        total_tools = len(self.tools)
        available_tools = len(self.list_available_tools())

        categories = {}
        for category in [
            "web",
            "network",
            "vulnerability",
            "subdomain",
            "ssl",
            "discovery",
        ]:
            categories[category] = len(self.get_tools_by_category(category))

        return {
            "total_registered": total_tools,
            "available_tools": available_tools,
            "unavailable_tools": total_tools - available_tools,
            "availability_rate": (available_tools / total_tools * 100)
            if total_tools > 0
            else 0,
            "categories": categories,
            "tool_names": list(self.tools.keys()),
        }

    def validate_registry(self) -> Dict[str, List[str]]:
        """
        Validate all registered tools and return issues

        Returns:
            Dictionary with validation results
        """
        issues = {
            "missing_tools": [],
            "unavailable_tools": [],
            "invalid_tools": [],
            "working_tools": [],
        }

        for name, tool in self.tools.items():
            try:
                # Check if tool instance is valid
                if not isinstance(tool, BaseTool):
                    issues["invalid_tools"].append(f"{name}: Not a BaseTool instance")
                    continue

                # Check if tool is available
                if not tool.is_available():
                    issues["unavailable_tools"].append(name)
                else:
                    issues["working_tools"].append(name)

                # Check if required methods are implemented
                try:
                    tool.get_description()
                    tool.get_input_schema()
                except Exception as e:
                    issues["invalid_tools"].append(
                        f"{name}: Method implementation error - {e}"
                    )

            except Exception as e:
                issues["invalid_tools"].append(f"{name}: Validation error - {e}")

        return issues
