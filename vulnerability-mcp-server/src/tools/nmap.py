"""
Nmap Network Discovery and Security Scanning Tool
Wrapper for the Nmap network scanner
"""

import os
import json
import xml.etree.ElementTree as ET
from typing import Dict, Any
from .base_tool import BaseTool


class NmapTool(BaseTool):
    """Nmap network scanner implementation"""

    def __init__(self):
        super().__init__()
        self.name = "nmap"
        self.description = "Network discovery and security auditing"

        # Find nmap executable
        self.tool_path = self._find_nmap_path()

    def _find_nmap_path(self) -> str:
        """Find nmap executable path"""
        possible_paths = [
            # System installations
            "nmap",  # Should be in PATH
            "/usr/bin/nmap",
            "/usr/local/bin/nmap",
            "C:\\Program Files (x86)\\Nmap\\nmap.exe",
            "C:\\Program Files\\Nmap\\nmap.exe",
        ]

        return self._find_tool_path(possible_paths)

    def get_description(self) -> str:
        return f"Nmap Network Scanner - Port scanning, service detection, OS fingerprinting, and vulnerability discovery. Path: {self.tool_path}"

    def get_input_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "target": {
                    "type": "string",
                    "description": "Target IP address, hostname, or IP range to scan",
                },
                "ports": {
                    "type": "string",
                    "description": "Port specification (e.g., '22,80,443', '1-1000', 'top-ports 100')",
                    "default": "top-ports 1000",
                },
                "scan_type": {
                    "type": "string",
                    "enum": [
                        "tcp_syn",
                        "tcp_connect",
                        "udp",
                        "tcp_ack",
                        "tcp_window",
                        "tcp_maimon",
                        "service_version",
                        "os_detection",
                    ],
                    "description": "Type of scan to perform",
                    "default": "tcp_syn",
                },
                "timing": {
                    "type": "string",
                    "enum": ["T0", "T1", "T2", "T3", "T4", "T5"],
                    "description": "Timing template (T0=paranoid, T5=insane)",
                    "default": "T3",
                },
                "service_detection": {
                    "type": "boolean",
                    "description": "Enable service/version detection",
                    "default": True,
                },
                "os_detection": {
                    "type": "boolean",
                    "description": "Enable OS detection",
                    "default": False,
                },
                "script_scan": {
                    "type": "boolean",
                    "description": "Enable default NSE script scanning",
                    "default": False,
                },
                "script_categories": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "NSE script categories to run (e.g., vuln, safe, intrusive)",
                },
                "output_format": {
                    "type": "string",
                    "enum": ["normal", "xml", "grepable"],
                    "description": "Output format preference",
                    "default": "xml",
                },
                "arguments": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "Additional nmap command-line arguments",
                },
            },
            "required": ["target"],
        }

    async def execute(self, params: Dict[str, Any]) -> str:
        """Execute Nmap network scan"""
        try:
            # Validate and extract parameters
            target = self._validate_target(params["target"])
            ports = params.get("ports", "top-ports 1000")
            scan_type = params.get("scan_type", "tcp_syn")
            timing = params.get("timing", "T3")
            service_detection = params.get("service_detection", True)
            os_detection = params.get("os_detection", False)
            script_scan = params.get("script_scan", False)
            script_categories = params.get("script_categories", [])
            output_format = params.get("output_format", "xml")
            extra_args = params.get("arguments", [])

            # Build the command
            cmd = self._build_command(
                target,
                ports,
                scan_type,
                timing,
                service_detection,
                os_detection,
                script_scan,
                script_categories,
                output_format,
                extra_args,
            )

            # Execute the scan (nmap can take a while)
            timeout = self._calculate_timeout(scan_type, ports, script_scan)
            result = await self._execute_command(cmd, timeout=timeout)

            # Format and return results
            return self._format_results(target, result, params, output_format)

        except ValueError as e:
            return self._format_error_response(
                str(e),
                suggestions=[
                    "Check target format (e.g., example.com, 192.168.1.1, 10.0.0.0/24)",
                    "Ensure target is accessible",
                ],
            )
        except Exception as e:
            return self._format_error_response(
                f"Nmap execution failed: {str(e)}",
                suggestions=[
                    "Verify Nmap is installed and accessible",
                    "Check target connectivity",
                    "Review scan parameters",
                    "Consider reducing scan scope or timing",
                ],
            )

    def _build_command(
        self,
        target: str,
        ports: str,
        scan_type: str,
        timing: str,
        service_detection: bool,
        os_detection: bool,
        script_scan: bool,
        script_categories: list,
        output_format: str,
        extra_args: list,
    ) -> list:
        """Build the nmap command"""

        cmd = [self.tool_path]

        # Add scan type
        scan_type_map = {
            "tcp_syn": "-sS",
            "tcp_connect": "-sT",
            "udp": "-sU",
            "tcp_ack": "-sA",
            "tcp_window": "-sW",
            "tcp_maimon": "-sM",
            "service_version": "-sV",
            "os_detection": "-O",
        }

        if scan_type in scan_type_map:
            cmd.append(scan_type_map[scan_type])
        else:
            cmd.append("-sS")  # Default to SYN scan

        # Add timing template
        cmd.append(f"-{timing}")

        # Add port specification
        if "top-ports" in ports:
            cmd.extend(["--" + ports.replace(" ", "-")])
        elif ports and ports != "all":
            cmd.extend(["-p", ports])
        # If ports is "all" or empty, nmap will use default port range

        # Add service detection
        if service_detection and scan_type != "service_version":
            cmd.append("-sV")

        # Add OS detection
        if os_detection and scan_type != "os_detection":
            cmd.append("-O")

        # Add script scanning
        if script_scan:
            if script_categories:
                cmd.extend(["--script", ",".join(script_categories)])
            else:
                cmd.append("-sC")  # Default scripts

        # Output format
        if output_format == "xml":
            cmd.append("-oX")
            cmd.append("-")  # Output to stdout
        elif output_format == "grepable":
            cmd.append("-oG")
            cmd.append("-")
        # Normal format is default

        # Reduce verbosity for cleaner output
        cmd.append("-v")

        # Add target
        cmd.append(target)

        # Add any additional arguments
        cmd.extend(extra_args)

        return cmd

    def _calculate_timeout(self, scan_type: str, ports: str, script_scan: bool) -> int:
        """Calculate appropriate timeout based on scan parameters"""
        base_timeout = 60  # 1 minute base

        # Adjust for scan type
        if scan_type in ["udp", "os_detection"]:
            base_timeout *= 3  # UDP and OS detection take longer
        elif script_scan:
            base_timeout *= 2  # Scripts add time

        # Adjust for port count
        if "top-ports" in ports:
            try:
                port_count = int(ports.split()[-1])
                if port_count > 1000:
                    base_timeout *= 2
            except (ValueError, IndexError):
                pass
        elif "-" in ports:
            # Port range
            base_timeout *= 2

        return min(base_timeout, 1800)  # Cap at 30 minutes

    def _format_results(
        self,
        target: str,
        result: Dict[str, Any],
        params: Dict[str, Any],
        output_format: str,
    ) -> str:
        """Format Nmap scan results"""

        response = "# ðŸŒ Nmap Network Scan Results\n\n"
        response += f"**Target:** {target}\n"
        response += f"**Ports:** {params.get('ports', 'default')}\n"
        response += f"**Scan Type:** {params.get('scan_type', 'tcp_syn')}\n"
        response += f"**Timing:** {params.get('timing', 'T3')}\n"
        response += f"**Command:** `{result.get('command', 'Unknown')}`\n\n"

        # Check execution status
        if result.get("timed_out"):
            timeout = self._calculate_timeout(
                params.get("scan_type", "tcp_syn"),
                params.get("ports", "top-ports 1000"),
                params.get("script_scan", False),
            )
            return self._format_timeout_response(timeout, target)

        return_code = result.get("return_code", -1)
        stdout = result.get("stdout", "")
        stderr = result.get("stderr", "")

        # Parse results based on output format
        if output_format == "xml" and stdout:
            scan_results = self._parse_xml_output(stdout)
        else:
            scan_results = self._parse_text_output(stdout)

        # Format summary
        response += "## ðŸ“Š Scan Summary\n\n"
        if return_code == 0:
            response += "**Status:** âœ… Completed Successfully\n"
        else:
            response += f"**Status:** âš ï¸ Completed with issues (code: {return_code})\n"

        hosts_up = len(
            [h for h in scan_results.get("hosts", []) if h.get("status") == "up"]
        )
        total_hosts = len(scan_results.get("hosts", []))
        open_ports = sum(len(h.get("ports", [])) for h in scan_results.get("hosts", []))

        response += f"**Hosts Scanned:** {total_hosts}\n"
        response += f"**Hosts Up:** {hosts_up}\n"
        response += f"**Open Ports Found:** {open_ports}\n\n"

        # Format host results
        for host in scan_results.get("hosts", []):
            if host.get("status") == "up":
                response += f"### ðŸ–¥ï¸ Host: {host.get('address', 'Unknown')}\n\n"

                # Host information
                if host.get("hostnames"):
                    response += f"**Hostnames:** {', '.join(host['hostnames'])}\n"

                if host.get("os_info"):
                    response += f"**OS Detected:** {host['os_info']}\n"

                response += f"**Status:** {host.get('status', 'unknown').upper()}\n\n"

                # Port information
                ports = host.get("ports", [])
                if ports:
                    response += "#### ðŸ”Œ Open Ports\n\n"

                    # Group ports by service for better readability
                    web_ports = []
                    ssh_ports = []
                    mail_ports = []
                    db_ports = []
                    other_ports = []

                    for port in ports:
                        service = port.get("service", "").lower()
                        if "http" in service or port.get("port") in [
                            80,
                            443,
                            8080,
                            8443,
                        ]:
                            web_ports.append(port)
                        elif "ssh" in service or port.get("port") == 22:
                            ssh_ports.append(port)
                        elif any(
                            mail in service for mail in ["smtp", "pop", "imap", "mail"]
                        ) or port.get("port") in [25, 110, 143, 993, 995]:
                            mail_ports.append(port)
                        elif any(
                            db in service
                            for db in ["mysql", "postgres", "mongo", "redis"]
                        ) or port.get("port") in [3306, 5432, 27017, 6379]:
                            db_ports.append(port)
                        else:
                            other_ports.append(port)

                    # Display categorized ports
                    for category, ports_list, emoji in [
                        ("Web Services", web_ports, "ðŸŒ"),
                        ("SSH Services", ssh_ports, "ðŸ”"),
                        ("Mail Services", mail_ports, "ðŸ“§"),
                        ("Database Services", db_ports, "ðŸ—„ï¸"),
                        ("Other Services", other_ports, "âš™ï¸"),
                    ]:
                        if ports_list:
                            response += f"**{emoji} {category}:**\n\n"
                            for port in ports_list:
                                port_num = port.get("port", "Unknown")
                                protocol = port.get("protocol", "tcp")
                                service = port.get("service", "unknown")
                                version = port.get("version", "")

                                response += (
                                    f"- **Port {port_num}/{protocol}** - {service}"
                                )
                                if version:
                                    response += f" ({version})"
                                response += "\n"

                                # Add any script results
                                if port.get("scripts"):
                                    for script_name, script_output in port[
                                        "scripts"
                                    ].items():
                                        response += f"  - *{script_name}:* {script_output[:200]}"
                                        if len(script_output) > 200:
                                            response += "..."
                                        response += "\n"
                            response += "\n"

                # Add any host scripts
                if host.get("host_scripts"):
                    response += "#### ðŸ“‹ Host Script Results\n\n"
                    for script_name, script_output in host["host_scripts"].items():
                        response += f"**{script_name}:**\n"
                        response += f"```\n{script_output[:500]}\n```\n"
                        if len(script_output) > 500:
                            response += "... (truncated)\n"
                        response += "\n"

        # Show warnings/errors if any
        if stderr:
            response += "## âš ï¸ Warnings/Errors\n\n"
            response += f"```\n{stderr[:1000]}\n```\n\n"
            if len(stderr) > 1000:
                response += "... (truncated)\n\n"

        # Recommendations
        response += "## ðŸ’¡ Security Recommendations\n\n"

        if open_ports > 0:
            response += "1. **Review Open Ports** - Ensure all open services are necessary and properly configured\n"
            response += "2. **Update Services** - Check for security updates for detected services\n"
            response += "3. **Firewall Rules** - Implement restrictive firewall rules for unnecessary ports\n"
            response += "4. **Service Hardening** - Follow security best practices for each identified service\n"
            response += (
                "5. **Regular Monitoring** - Implement continuous network monitoring\n"
            )
        else:
            response += "1. **Verify Results** - No open ports detected; verify this is expected\n"
            response += (
                "2. **Firewall Check** - Confirm firewall is properly configured\n"
            )
            response += (
                "3. **Alternative Scans** - Consider different scan types or timing\n"
            )
            response += "4. **Internal vs External** - Results may differ from internal vs external perspectives\n"

        # Add intelligence notes
        if params.get("service_detection") or params.get("script_scan"):
            response += "\n**Note:** Service detection and script scanning can reveal additional attack vectors. "
            response += "Prioritize securing services with known vulnerabilities or misconfigurations.\n"

        return response

    def _parse_xml_output(self, xml_output: str) -> Dict[str, Any]:
        """Parse Nmap XML output"""
        results = {"hosts": []}

        try:
            root = ET.fromstring(xml_output)

            for host in root.findall(".//host"):
                host_data = {"ports": [], "hostnames": [], "host_scripts": {}}

                # Get host status
                status = host.find("status")
                if status is not None:
                    host_data["status"] = status.get("state", "unknown")

                # Get host address
                address = host.find("address")
                if address is not None:
                    host_data["address"] = address.get("addr", "Unknown")

                # Get hostnames
                hostnames = host.find("hostnames")
                if hostnames is not None:
                    for hostname in hostnames.findall("hostname"):
                        host_data["hostnames"].append(hostname.get("name", ""))

                # Get OS information
                os_elem = host.find("os")
                if os_elem is not None:
                    osmatch = os_elem.find("osmatch")
                    if osmatch is not None:
                        host_data["os_info"] = osmatch.get("name", "")

                # Get port information
                ports = host.find("ports")
                if ports is not None:
                    for port in ports.findall("port"):
                        port_data = {}
                        port_data["port"] = int(port.get("portid", 0))
                        port_data["protocol"] = port.get("protocol", "tcp")

                        # Get port state
                        state = port.find("state")
                        if state is not None and state.get("state") == "open":
                            # Get service information
                            service = port.find("service")
                            if service is not None:
                                port_data["service"] = service.get("name", "unknown")
                                port_data["version"] = service.get("product", "")
                                if service.get("version"):
                                    port_data["version"] += f" {service.get('version')}"

                            # Get script results
                            scripts = {}
                            for script in port.findall("script"):
                                script_id = script.get("id", "unknown")
                                script_output = script.get("output", "")
                                scripts[script_id] = script_output

                            if scripts:
                                port_data["scripts"] = scripts

                            host_data["ports"].append(port_data)

                # Get host scripts
                hostscript = host.find("hostscript")
                if hostscript is not None:
                    for script in hostscript.findall("script"):
                        script_id = script.get("id", "unknown")
                        script_output = script.get("output", "")
                        host_data["host_scripts"][script_id] = script_output

                results["hosts"].append(host_data)

        except ET.ParseError:
            # Fall back to text parsing if XML is malformed
            return self._parse_text_output(xml_output)

        return results

    def _parse_text_output(self, text_output: str) -> Dict[str, Any]:
        """Parse Nmap text output (fallback)"""
        results = {"hosts": []}
        current_host = None

        for line in text_output.split("\n"):
            line = line.strip()

            # Look for host lines
            if "Nmap scan report for" in line:
                if current_host:
                    results["hosts"].append(current_host)

                current_host = {
                    "address": line.split("for ")[-1].strip(),
                    "status": "up",
                    "ports": [],
                    "hostnames": [],
                }

            # Look for port lines
            elif (
                current_host
                and "/" in line
                and ("open" in line or "closed" in line or "filtered" in line)
            ):
                if "open" in line:
                    parts = line.split()
                    if len(parts) >= 2:
                        port_proto = parts[0]
                        if "/" in port_proto:
                            port, protocol = port_proto.split("/", 1)
                            try:
                                port_data = {
                                    "port": int(port),
                                    "protocol": protocol,
                                    "service": parts[2]
                                    if len(parts) > 2
                                    else "unknown",
                                }
                                current_host["ports"].append(port_data)
                            except ValueError:
                                pass

        # Don't forget the last host
        if current_host:
            results["hosts"].append(current_host)

        return results

    def is_available(self) -> bool:
        """Check if Nmap is available"""
        try:
            import subprocess

            result = subprocess.run(
                [self.tool_path, "--version"], capture_output=True, timeout=10
            )
            return result.returncode == 0
        except Exception:
            return False
