"""
Nuclei Vulnerability Scanner Tool
Wrapper for the Nuclei fast and customizable vulnerability scanner
"""

import os
import json
import tempfile
from typing import Dict, Any
from .base_tool import BaseTool


class NucleiTool(BaseTool):
    """Nuclei vulnerability scanner implementation"""

    def __init__(self):
        super().__init__()
        self.name = "nuclei"
        self.description = "Fast and customizable vulnerability scanner"

        # Find nuclei executable
        self.tool_path = self._find_nuclei_path()

    def _find_nuclei_path(self) -> str:
        """Find nuclei executable path"""
        username = os.getenv("USERNAME", os.getenv("USER", "user"))

        possible_paths = [
            # Project tools
            rf"C:\Users\{username}\Documents\My Files\Programes\IITM\Subd_IITM\tools\nuclei.exe",
            # Go installation paths
            rf"C:\Users\{username}\go\bin\nuclei.exe",
            rf"C:\Users\{username}\AppData\Local\go\bin\nuclei.exe",
            # System installations
            "nuclei",  # Should be in PATH
            "/usr/bin/nuclei",
            "/usr/local/bin/nuclei",
        ]

        return self._find_tool_path(possible_paths)

    def get_description(self) -> str:
        return f"Nuclei Vulnerability Scanner - Fast and customizable vulnerability scanner with community templates. Path: {self.tool_path}"

    def get_input_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "target": {
                    "type": "string",
                    "description": "Target URL, IP address, or hostname to scan",
                },
                "templates": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "Specific template tags/paths to use (e.g., 'cve', 'oast', 'network', 'wordpress')",
                },
                "severity": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "enum": ["info", "low", "medium", "high", "critical"],
                    },
                    "description": "Filter by severity levels",
                    "default": ["medium", "high", "critical"],
                },
                "concurrency": {
                    "type": "integer",
                    "description": "Number of concurrent requests",
                    "default": 25,
                    "minimum": 1,
                    "maximum": 100,
                },
                "rate_limit": {
                    "type": "integer",
                    "description": "Maximum requests per second",
                    "default": 150,
                    "minimum": 1,
                    "maximum": 500,
                },
                "timeout": {
                    "type": "integer",
                    "description": "Request timeout in seconds",
                    "default": 5,
                    "minimum": 1,
                    "maximum": 60,
                },
                "follow_redirects": {
                    "type": "boolean",
                    "description": "Follow HTTP redirects",
                    "default": False,
                },
                "include_tags": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "Include templates with specific tags",
                },
                "exclude_tags": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "Exclude templates with specific tags",
                },
                "custom_headers": {
                    "type": "object",
                    "description": "Custom HTTP headers as key-value pairs",
                },
                "arguments": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "Additional nuclei command-line arguments",
                },
            },
            "required": ["target"],
        }

    async def execute(self, params: Dict[str, Any]) -> str:
        """Execute Nuclei vulnerability scan"""
        try:
            # Validate and extract parameters
            target = self._validate_target(params["target"])
            templates = params.get("templates", [])
            severity = params.get("severity", ["medium", "high", "critical"])
            concurrency = params.get("concurrency", 25)
            rate_limit = params.get("rate_limit", 150)
            timeout = params.get("timeout", 5)
            follow_redirects = params.get("follow_redirects", False)
            include_tags = params.get("include_tags", [])
            exclude_tags = params.get("exclude_tags", [])
            custom_headers = params.get("custom_headers", {})
            extra_args = params.get("arguments", [])

            # Build the command
            cmd = self._build_command(
                target,
                templates,
                severity,
                concurrency,
                rate_limit,
                timeout,
                follow_redirects,
                include_tags,
                exclude_tags,
                custom_headers,
                extra_args,
            )

            # Calculate appropriate timeout
            scan_timeout = max(timeout * 60, 300)  # At least 5 minutes

            # Execute the scan
            result = await self._execute_command(cmd, timeout=scan_timeout)

            # Format and return results
            return self._format_results(target, result, params)

        except ValueError as e:
            return self._format_error_response(
                str(e),
                suggestions=[
                    "Check target format (e.g., https://example.com)",
                    "Ensure target is accessible",
                ],
            )
        except Exception as e:
            return self._format_error_response(
                f"Nuclei execution failed: {str(e)}",
                suggestions=[
                    "Verify Nuclei is installed and accessible",
                    "Check target connectivity",
                    "Ensure templates are available",
                    "Review scan parameters",
                ],
            )

    def _build_command(
        self,
        target: str,
        templates: list,
        severity: list,
        concurrency: int,
        rate_limit: int,
        timeout: int,
        follow_redirects: bool,
        include_tags: list,
        exclude_tags: list,
        custom_headers: dict,
        extra_args: list,
    ) -> list:
        """Build the nuclei command"""

        cmd = [self.tool_path]

        # Add target
        if target.startswith(("http://", "https://")):
            cmd.extend(["-u", target])
        else:
            # Assume it's a host and try both HTTP and HTTPS
            cmd.extend(["-u", f"http://{target},https://{target}"])

        # Add templates if specified
        if templates:
            # Handle both tag-based and file-based templates
            template_args = []
            for template in templates:
                if template in [
                    "cve",
                    "oast",
                    "network",
                    "wordpress",
                    "joomla",
                    "drupal",
                    "misconfig",
                    "exposed-panels",
                ]:
                    template_args.extend(["-tags", template])
                else:
                    template_args.extend(["-t", template])
            cmd.extend(template_args)
        else:
            # Use default community templates
            cmd.extend(["-tags", "cve,misconfig,exposed-panels,wordpress"])

        # Add severity filter
        if severity:
            cmd.extend(["-severity", ",".join(severity)])

        # Add performance settings
        cmd.extend(
            [
                "-c",
                str(concurrency),
                "-rate-limit",
                str(rate_limit),
                "-timeout",
                str(timeout),
            ]
        )

        # Add redirect behavior
        if follow_redirects:
            cmd.append("-follow-redirects")

        # Add include tags
        if include_tags:
            cmd.extend(["-include-tags", ",".join(include_tags)])

        # Add exclude tags
        if exclude_tags:
            cmd.extend(["-exclude-tags", ",".join(exclude_tags)])

        # Add custom headers
        if custom_headers:
            for key, value in custom_headers.items():
                cmd.extend(["-H", f"{key}: {value}"])

        # Output format (JSON for easier parsing)
        cmd.extend(["-json", "-silent"])

        # Disable update check to avoid hanging
        cmd.append("-disable-update-check")

        # Add any additional arguments
        cmd.extend(extra_args)

        return cmd

    def _format_results(
        self, target: str, result: Dict[str, Any], params: Dict[str, Any]
    ) -> str:
        """Format Nuclei scan results"""

        response = "# ðŸŽ¯ Nuclei Vulnerability Scan Results\n\n"
        response += f"**Target:** {target}\n"
        response += (
            f"**Templates:** {', '.join(params.get('templates', ['default']))}\n"
        )
        response += f"**Severity Filter:** {', '.join(params.get('severity', ['medium', 'high', 'critical']))}\n"
        response += f"**Command:** `{result.get('command', 'Unknown')}`\n\n"

        # Check execution status
        if result.get("timed_out"):
            return self._format_timeout_response(params.get("timeout", 5) * 60, target)

        return_code = result.get("return_code", -1)
        stdout = result.get("stdout", "")
        stderr = result.get("stderr", "")

        # Parse JSON output
        vulnerabilities = self._parse_nuclei_output(stdout)

        # Format summary
        response += "## ðŸ“Š Scan Summary\n\n"
        if return_code == 0:
            response += "**Status:** âœ… Completed Successfully\n"
        else:
            response += f"**Status:** âš ï¸ Completed with issues (code: {return_code})\n"

        response += f"**Vulnerabilities Found:** {len(vulnerabilities)}\n"

        # Count by severity
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        for vuln in vulnerabilities:
            severity = vuln.get("info", {}).get("severity", "info").lower()
            if severity in severity_counts:
                severity_counts[severity] += 1

        response += f"**Critical:** {severity_counts['critical']} | "
        response += f"**High:** {severity_counts['high']} | "
        response += f"**Medium:** {severity_counts['medium']} | "
        response += f"**Low:** {severity_counts['low']} | "
        response += f"**Info:** {severity_counts['info']}\n\n"

        # Format vulnerabilities by severity
        if vulnerabilities:
            response += "## ðŸš¨ Vulnerabilities Detected\n\n"

            # Group by severity
            for severity_level, emoji in [
                ("critical", "ðŸ”´"),
                ("high", "ðŸŸ "),
                ("medium", "ðŸŸ¡"),
                ("low", "ðŸŸ¢"),
                ("info", "ðŸ”µ"),
            ]:
                severity_vulns = [
                    v
                    for v in vulnerabilities
                    if v.get("info", {}).get("severity", "").lower() == severity_level
                ]

                if severity_vulns:
                    response += f"### {emoji} {severity_level.title()} Severity ({len(severity_vulns)} findings)\n\n"

                    for i, vuln in enumerate(
                        severity_vulns[:15], 1
                    ):  # Limit to 15 per severity
                        info = vuln.get("info", {})

                        response += (
                            f"**{i}. {info.get('name', 'Unknown Vulnerability')}**\n"
                        )

                        # Template info
                        template_id = vuln.get("template-id", "unknown")
                        response += f"   - **Template:** {template_id}\n"

                        # Description
                        description = info.get(
                            "description", "No description available"
                        )
                        response += f"   - **Description:** {description}\n"

                        # Matched URL
                        matched_at = vuln.get("matched-at", vuln.get("matched", ""))
                        if matched_at:
                            response += f"   - **Matched At:** {matched_at}\n"

                        # CVE references
                        classification = info.get("classification", {})
                        if classification.get("cve-id"):
                            cves = classification["cve-id"]
                            if isinstance(cves, list):
                                response += f"   - **CVE:** {', '.join(cves)}\n"
                            else:
                                response += f"   - **CVE:** {cves}\n"

                        # CWE references
                        if classification.get("cwe-id"):
                            cwes = classification["cwe-id"]
                            if isinstance(cwes, list):
                                response += (
                                    f"   - **CWE:** {', '.join(map(str, cwes))}\n"
                                )
                            else:
                                response += f"   - **CWE:** {cwes}\n"

                        # Tags
                        tags = info.get("tags", [])
                        if tags:
                            if isinstance(tags, list):
                                response += f"   - **Tags:** {', '.join(tags[:5])}\n"  # Limit tags
                            else:
                                response += f"   - **Tags:** {tags}\n"

                        # References
                        references = info.get("reference", [])
                        if references:
                            if isinstance(references, list):
                                response += f"   - **References:** {references[0]}"
                                if len(references) > 1:
                                    response += f" (+{len(references) - 1} more)"
                                response += "\n"
                            else:
                                response += f"   - **References:** {references}\n"

                        response += "\n"

                    if len(severity_vulns) > 15:
                        response += f"   ... and {len(severity_vulns) - 15} more {severity_level} severity findings\n\n"

        else:
            response += "## âœ… No Vulnerabilities Detected\n\n"
            response += "Nuclei did not identify any vulnerabilities matching the specified criteria.\n"
            response += "This doesn't guarantee the target is secure - consider:\n"
            response += "- Running with different templates or severity levels\n"
            response += "- Checking for false negatives\n"
            response += "- Performing manual testing\n\n"

        # Show errors/warnings if any
        if stderr:
            response += "## âš ï¸ Warnings/Errors\n\n"
            error_lines = stderr.strip().split("\n")
            relevant_errors = [
                line
                for line in error_lines
                if not line.startswith("[") or "error" in line.lower()
            ]

            if relevant_errors:
                response += f"```\n{chr(10).join(relevant_errors[:10])}\n```\n\n"
                if len(relevant_errors) > 10:
                    response += f"... and {len(relevant_errors) - 10} more messages\n\n"

        # Recommendations
        response += "## ðŸ’¡ Remediation Recommendations\n\n"

        if vulnerabilities:
            # Prioritize by severity
            critical_high = severity_counts["critical"] + severity_counts["high"]
            if critical_high > 0:
                response += f"1. **ðŸš¨ URGENT: Address {critical_high} Critical/High severity issues immediately**\n"
                response += (
                    "   - These vulnerabilities pose significant security risks\n"
                )
                response += "   - Prioritize CVE-tagged vulnerabilities\n"
                response += "   - Apply patches or implement workarounds\n\n"

            if severity_counts["medium"] > 0:
                response += f"2. **âš ï¸ Address {severity_counts['medium']} Medium severity issues**\n"
                response += "   - These vulnerabilities should be resolved promptly\n"
                response += "   - Review configuration misconfigurations\n\n"

            response += "3. **ðŸ” Verification and Follow-up**\n"
            response += "   - Manually verify all automated findings\n"
            response += "   - Test patches in a staging environment\n"
            response += "   - Re-scan after applying fixes\n\n"

            response += "4. **ðŸ›¡ï¸ Preventive Measures**\n"
            response += "   - Implement regular vulnerability scanning\n"
            response += "   - Keep software and dependencies updated\n"
            response += "   - Follow security best practices\n"

        else:
            response += "1. **âœ… Current Status: No vulnerabilities detected**\n"
            response += "2. **ðŸ”„ Continue Monitoring: Run regular scans with updated templates**\n"
            response += (
                "3. **ðŸŽ¯ Expand Coverage: Consider different template categories**\n"
            )
            response += (
                "4. **ðŸ› ï¸ Manual Testing: Supplement with manual security testing**\n"
            )

        return response

    def _parse_nuclei_output(self, output: str) -> list:
        """Parse Nuclei JSON output"""
        vulnerabilities = []

        if not output or not output.strip():
            return vulnerabilities

        try:
            # Nuclei outputs one JSON object per line
            for line in output.strip().split("\n"):
                line = line.strip()
                if line and line.startswith("{"):
                    try:
                        vuln = json.loads(line)
                        vulnerabilities.append(vuln)
                    except json.JSONDecodeError:
                        continue

        except Exception:
            # If JSON parsing completely fails, try to extract basic info from text
            for line in output.split("\n"):
                if "found" in line.lower() or "detected" in line.lower():
                    vulnerabilities.append(
                        {
                            "template-id": "unknown",
                            "info": {
                                "name": "Finding",
                                "severity": "medium",
                                "description": line.strip(),
                            },
                        }
                    )

        return vulnerabilities

    def is_available(self) -> bool:
        """Check if Nuclei is available"""
        try:
            import subprocess

            result = subprocess.run(
                [self.tool_path, "-version"], capture_output=True, timeout=10
            )
            return result.returncode == 0
        except Exception:
            return False
