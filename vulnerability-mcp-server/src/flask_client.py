"""
Flask Backend Client for retrieving vulnerability data
Provides async interface to communicate with the existing Flask vulnerability analysis backend
"""

import aiohttp
import asyncio
import logging
from typing import Dict, Any, Optional
from urllib.parse import urljoin
import json

logger = logging.getLogger(__name__)


class FlaskBackendClient:
    """Async HTTP client for Flask backend communication"""

    def __init__(self, base_url: str = "http://localhost:5000"):
        self.base_url = base_url.rstrip("/")
        self.session = None
        self.timeout = aiohttp.ClientTimeout(total=300)  # 5 minutes

    async def _get_session(self) -> aiohttp.ClientSession:
        """Get or create aiohttp session"""
        if self.session is None or self.session.closed:
            self.session = aiohttp.ClientSession(timeout=self.timeout)
        return self.session

    async def get_vulnerability_data(
        self, target: str, scan_type: str = "comprehensive"
    ) -> Dict[str, Any]:
        """
        Retrieve comprehensive vulnerability data from Flask backend

        Args:
            target: Target domain or IP address
            scan_type: Type of scan (quick, comprehensive, targeted, deep)

        Returns:
            Dictionary containing vulnerability analysis data
        """
        session = await self._get_session()

        try:
            # Prepare request data
            request_data = {
                "target": target,
                "scan_type": scan_type,
                "include_subdomains": True,
                "include_services": True,
                "include_vulnerabilities": True,
                "include_ssl_analysis": True,
                "include_technology_detection": True,
            }

            # Determine the appropriate endpoint
            endpoint = "/api/scan"
            if scan_type == "quick":
                endpoint = "/api/scan/quick"
            elif scan_type == "deep":
                endpoint = "/api/scan/deep"
            elif scan_type == "targeted":
                endpoint = "/api/scan/targeted"

            url = urljoin(self.base_url, endpoint)

            logger.info(f"Requesting vulnerability data from {url} for target {target}")

            # Make request to Flask backend
            async with session.post(
                url,
                json=request_data,
                headers={
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                },
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    logger.info(
                        f"Successfully retrieved vulnerability data for {target}"
                    )

                    # Ensure data structure is complete
                    return self._normalize_response_data(data)

                elif response.status == 202:
                    # Async scan started, need to poll for results
                    data = await response.json()
                    scan_id = data.get("scan_id")
                    if scan_id:
                        return await self._poll_scan_results(scan_id)
                    else:
                        raise Exception("Async scan started but no scan ID provided")

                else:
                    error_text = await response.text()
                    logger.error(f"Flask backend error {response.status}: {error_text}")
                    raise Exception(f"Backend error {response.status}: {error_text}")

        except aiohttp.ClientError as e:
            logger.error(f"Connection error to Flask backend: {e}")
            # Return mock data structure for testing when backend is unavailable
            return self._get_mock_data(target, scan_type)

        except Exception as e:
            logger.error(f"Unexpected error retrieving data for {target}: {e}")
            raise

    async def _poll_scan_results(
        self, scan_id: str, max_attempts: int = 60, interval: int = 10
    ) -> Dict[str, Any]:
        """Poll for async scan results"""
        session = await self._get_session()

        for attempt in range(max_attempts):
            try:
                async with session.get(
                    urljoin(self.base_url, f"/api/scan/{scan_id}/status")
                ) as response:
                    if response.status == 200:
                        data = await response.json()

                        status = data.get("status", "unknown")
                        if status == "completed":
                            return self._normalize_response_data(
                                data.get("results", {})
                            )
                        elif status == "failed":
                            raise Exception(
                                f"Scan failed: {data.get('error', 'Unknown error')}"
                            )
                        elif status in ["running", "pending"]:
                            logger.info(
                                f"Scan {scan_id} still running, attempt {attempt + 1}/{max_attempts}"
                            )
                            await asyncio.sleep(interval)
                            continue
                        else:
                            raise Exception(f"Unknown scan status: {status}")
                    else:
                        error_text = await response.text()
                        raise Exception(
                            f"Status check failed {response.status}: {error_text}"
                        )

            except Exception as e:
                if attempt == max_attempts - 1:
                    raise Exception(
                        f"Scan polling timeout after {max_attempts} attempts: {e}"
                    )
                logger.warning(f"Polling attempt {attempt + 1} failed: {e}")
                await asyncio.sleep(interval)

        raise Exception("Scan polling timeout")

    def _normalize_response_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Normalize and validate response data structure"""
        normalized = {
            "timestamp": data.get("timestamp", "N/A"),
            "target": data.get("target", "Unknown"),
            "scan_type": data.get("scan_type", "unknown"),
            "subdomains": data.get("subdomains", []),
            "services": data.get("services", []),
            "vulnerabilities": data.get("vulnerabilities", []),
            "ssl_issues": data.get("ssl_issues", []),
            "technologies": data.get("technologies", []),
            "ports": data.get("ports", []),
            "dns_records": data.get("dns_records", []),
            "certificates": data.get("certificates", []),
            "geolocation": data.get("geolocation", {}),
            "reputation": data.get("reputation", {}),
            "metadata": {
                "scan_duration": data.get("scan_duration", 0),
                "tools_used": data.get("tools_used", []),
                "confidence_score": data.get("confidence_score", 0.0),
                "completeness": data.get("completeness", "unknown"),
            },
        }

        return normalized

    def _get_mock_data(self, target: str, scan_type: str) -> Dict[str, Any]:
        """Return mock data when backend is unavailable (for testing)"""
        logger.warning(f"Using mock data for {target} due to backend unavailability")

        return {
            "timestamp": "2025-08-13T11:30:00Z",
            "target": target,
            "scan_type": scan_type,
            "subdomains": [
                f"www.{target}",
                f"api.{target}",
                f"admin.{target}",
                f"mail.{target}",
            ],
            "services": [
                {"port": 80, "service": "http", "version": "nginx/1.18.0"},
                {"port": 443, "service": "https", "version": "nginx/1.18.0"},
                {"port": 22, "service": "ssh", "version": "OpenSSH 8.2"},
            ],
            "vulnerabilities": [
                {
                    "id": "CVE-2023-MOCK",
                    "title": "Mock Vulnerability for Testing",
                    "severity": "Medium",
                    "description": "This is mock vulnerability data used when Flask backend is unavailable",
                }
            ],
            "ssl_issues": [],
            "technologies": ["Nginx", "Ubuntu", "OpenSSL"],
            "ports": [22, 80, 443],
            "dns_records": [
                {"type": "A", "value": "192.168.1.1"},
                {"type": "MX", "value": f"mail.{target}"},
            ],
            "certificates": [],
            "geolocation": {"country": "Unknown", "city": "Unknown"},
            "reputation": {"score": 0, "sources": []},
            "metadata": {
                "scan_duration": 0,
                "tools_used": ["mock_scanner"],
                "confidence_score": 0.1,
                "completeness": "mock_data",
            },
        }

    async def get_scan_status(self, scan_id: str) -> Dict[str, Any]:
        """Get status of a running scan"""
        session = await self._get_session()

        try:
            async with session.get(
                urljoin(self.base_url, f"/api/scan/{scan_id}/status")
            ) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    error_text = await response.text()
                    raise Exception(
                        f"Status check failed {response.status}: {error_text}"
                    )
        except Exception as e:
            logger.error(f"Error checking scan status: {e}")
            raise

    async def get_historical_data(self, target: str, limit: int = 10) -> Dict[str, Any]:
        """Get historical vulnerability data for target"""
        session = await self._get_session()

        try:
            params = {"limit": limit}
            async with session.get(
                urljoin(self.base_url, f"/api/history/{target}"), params=params
            ) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    error_text = await response.text()
                    raise Exception(
                        f"History retrieval failed {response.status}: {error_text}"
                    )
        except Exception as e:
            logger.error(f"Error retrieving historical data: {e}")
            raise

    async def start_async_scan(
        self, target: str, scan_type: str = "comprehensive"
    ) -> str:
        """Start an asynchronous scan and return scan ID"""
        session = await self._get_session()

        try:
            request_data = {"target": target, "scan_type": scan_type, "async": True}

            async with session.post(
                urljoin(self.base_url, "/api/scan/async"),
                json=request_data,
                headers={"Content-Type": "application/json"},
            ) as response:
                if response.status in [200, 202]:
                    data = await response.json()
                    return data.get("scan_id")
                else:
                    error_text = await response.text()
                    raise Exception(
                        f"Async scan start failed {response.status}: {error_text}"
                    )
        except Exception as e:
            logger.error(f"Error starting async scan: {e}")
            raise

    def get_config(self) -> Dict[str, Any]:
        """Get current client configuration"""
        return {
            "base_url": self.base_url,
            "timeout_seconds": self.timeout.total if self.timeout else "None",
            "endpoints": {
                "scan": "/api/scan",
                "quick_scan": "/api/scan/quick",
                "deep_scan": "/api/scan/deep",
                "targeted_scan": "/api/scan/targeted",
                "async_scan": "/api/scan/async",
                "status": "/api/scan/{id}/status",
                "history": "/api/history/{target}",
            },
            "features": [
                "Subdomain Discovery",
                "Service Detection",
                "Vulnerability Scanning",
                "SSL/TLS Analysis",
                "Technology Detection",
                "Historical Data",
                "Async Scanning",
            ],
        }

    async def health_check(self) -> bool:
        """Check if Flask backend is healthy and responding"""
        session = await self._get_session()

        try:
            async with session.get(
                urljoin(self.base_url, "/api/health"),
                timeout=aiohttp.ClientTimeout(total=10),
            ) as response:
                return response.status == 200
        except Exception as e:
            logger.warning(f"Flask backend health check failed: {e}")
            return False

    async def close(self):
        """Close the HTTP session"""
        if self.session and not self.session.closed:
            await self.session.close()
            logger.info("Flask client session closed")
