"""
Base Tool Class for Vulnerability Scanners
Provides common interface and functionality for all security tools
"""

import asyncio
import os
import logging
import subprocess
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)


class BaseTool(ABC):
    """Abstract base class for all vulnerability scanning tools"""

    def __init__(self):
        self.name = "base_tool"
        self.description = "Base vulnerability scanning tool"
        self.tool_path = None
        self.timeout = 300  # Default 5-minute timeout
        self.max_retries = 2

    @abstractmethod
    def get_description(self) -> str:
        """Return human-readable description of the tool"""
        pass

    @abstractmethod
    def get_input_schema(self) -> Dict[str, Any]:
        """Return JSON schema for tool input parameters"""
        pass

    @abstractmethod
    async def execute(self, params: Dict[str, Any]) -> str:
        """Execute the tool with given parameters and return formatted results"""
        pass

    def is_available(self) -> bool:
        """Check if the tool is available and can be executed"""
        try:
            # Check if tool path exists
            if self.tool_path and os.path.exists(self.tool_path):
                return True

            # Check if tool is in PATH
            if self.name:
                result = subprocess.run(
                    [self.name, "--help"], capture_output=True, timeout=10, text=True
                )
                return result.returncode in [0, 1]  # Many tools return 1 for --help

        except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
            pass

        return False

    def _validate_target(self, target: str) -> str:
        """Validate and normalize target input"""
        if not target or not isinstance(target, str):
            raise ValueError("Target must be a non-empty string")

        target = target.strip()
        if not target:
            raise ValueError("Target cannot be empty or whitespace only")

        # Remove protocol if present for consistency
        if target.startswith(("http://", "https://")):
            target = target.split("://", 1)[1]

        return target

    def _find_tool_path(self, possible_paths: List[str]) -> str:
        """Find tool executable from list of possible paths"""
        for path in possible_paths:
            # Expand environment variables and user paths
            expanded_path = os.path.expandvars(os.path.expanduser(path))

            if os.path.exists(expanded_path):
                if os.access(expanded_path, os.X_OK) or expanded_path.endswith(
                    (".exe", ".pl", ".sh")
                ):
                    return expanded_path

        # Fallback to command name (assume it's in PATH)
        return self.name

    async def _execute_command(
        self, cmd: List[str], timeout: Optional[int] = None
    ) -> Dict[str, Any]:
        """Execute command safely with timeout and error handling"""
        if timeout is None:
            timeout = self.timeout

        logger.debug(f"Executing command: {' '.join(cmd)}")

        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                stdin=asyncio.subprocess.DEVNULL,
            )

            stdout, stderr = await asyncio.wait_for(
                process.communicate(), timeout=timeout
            )

            return {
                "return_code": process.returncode,
                "stdout": stdout.decode("utf-8", errors="ignore") if stdout else "",
                "stderr": stderr.decode("utf-8", errors="ignore") if stderr else "",
                "command": " ".join(cmd),
                "timed_out": False,
            }

        except asyncio.TimeoutError:
            logger.error(f"Command timed out after {timeout} seconds: {' '.join(cmd)}")
            if "process" in locals():
                try:
                    process.terminate()
                    await asyncio.sleep(2)
                    if process.returncode is None:
                        process.kill()
                except:
                    pass

            return {
                "return_code": -1,
                "stdout": "",
                "stderr": f"Command timed out after {timeout} seconds",
                "command": " ".join(cmd),
                "timed_out": True,
            }

        except Exception as e:
            logger.error(f"Command execution failed: {e}")
            return {
                "return_code": -1,
                "stdout": "",
                "stderr": str(e),
                "command": " ".join(cmd),
                "timed_out": False,
            }

    def _format_error_response(
        self, error: str, command: str = "", suggestions: List[str] = None
    ) -> str:
        """Format standardized error response"""
        response = f"❌ **{self.name.title()} Error**\n\n"
        response += f"**Error:** {error}\n"

        if command:
            response += f"**Command:** `{command}`\n"

        if suggestions:
            response += f"\n**Troubleshooting Suggestions:**\n"
            for i, suggestion in enumerate(suggestions, 1):
                response += f"{i}. {suggestion}\n"

        return response

    def _format_timeout_response(self, timeout: int, target: str) -> str:
        """Format standardized timeout response"""
        response = f"⏱️ **{self.name.title()} Scan Timeout**\n\n"
        response += f"**Target:** {target}\n"
        response += f"**Timeout:** {timeout} seconds\n\n"
        response += f"**Possible Causes:**\n"
        response += f"- Target is unresponsive or filtered\n"
        response += f"- Network connectivity issues\n"
        response += f"- Target has extensive security controls\n"
        response += f"- Scan parameters too aggressive\n\n"
        response += f"**Recommendations:**\n"
        response += f"- Verify target is accessible\n"
        response += f"- Try with reduced scan intensity\n"
        response += f"- Check network/firewall settings\n"

        return response

    def _extract_vulnerabilities_count(self, output: str) -> int:
        """Extract vulnerability count from tool output (override in subclasses)"""
        # Default implementation - look for common patterns
        import re

        patterns = [
            r"(\d+)\s+vulnerabilities?\s+found",
            r"(\d+)\s+issues?\s+found",
            r"(\d+)\s+findings?",
            r"Total:\s*(\d+)",
            r"Found\s+(\d+)",
        ]

        for pattern in patterns:
            match = re.search(pattern, output.lower())
            if match:
                return int(match.group(1))

        return 0

    def _get_common_paths(self) -> List[str]:
        """Get common tool installation paths for Windows/WSL environment"""
        username = os.getenv("USERNAME", os.getenv("USER", "user"))

        return [
            # Project tools directory
            rf"C:\Users\{username}\Documents\My Files\Programes\IITM\Subd_IITM\tools\{self.name}",
            rf"C:\Users\{username}\Documents\My Files\Programes\IITM\Subd_IITM\tools\{self.name}.exe",
            # Security tools directory
            rf"C:\Users\{username}\security-tools\{self.name}",
            rf"C:\Users\{username}\security-tools\{self.name}\{self.name}",
            rf"C:\Users\{username}\security-tools\{self.name}\{self.name}.exe",
            # Go tools
            rf"C:\Users\{username}\go\bin\{self.name}.exe",
            # Common Windows installations
            rf"C:\Program Files\{self.name}\{self.name}.exe",
            rf"C:\Program Files (x86)\{self.name}\{self.name}.exe",
            rf"C:\tools\{self.name}\{self.name}.exe",
            # WSL paths (accessible from Windows)
            rf"/mnt/c/Users/{username}/security-tools/{self.name}",
            f"/usr/bin/{self.name}",
            f"/usr/local/bin/{self.name}",
        ]
