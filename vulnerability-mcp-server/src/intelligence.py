"""
Intelligence Engine for Vulnerability Analysis
Smart tool selection and orchestration to avoid false positives and optimize scanning
"""

import re
import urllib.parse
from typing import Dict, Any, List, Tuple, Optional
from dataclasses import dataclass


@dataclass
class AnalysisContext:
    """Context information for intelligent analysis"""

    target: str
    target_type: str  # 'domain', 'ip', 'url', 'network'
    protocol: Optional[str] = None
    port: Optional[int] = None
    path: Optional[str] = None
    previous_results: Dict[str, Any] = None
    risk_level: str = "medium"  # 'low', 'medium', 'high'
    time_budget: int = 300  # seconds


class VulnerabilityIntelligence:
    """Intelligence engine for smart vulnerability analysis"""

    def __init__(self):
        self.tool_capabilities = self._initialize_tool_capabilities()
        self.analysis_strategies = self._initialize_analysis_strategies()

    def _initialize_tool_capabilities(self) -> Dict[str, Dict[str, Any]]:
        """Define capabilities and characteristics of each tool"""
        return {
            "nmap": {
                "primary_use": "network_discovery",
                "targets": ["ip", "domain", "network"],
                "protocols": ["tcp", "udp"],
                "speed": "medium",
                "noise_level": "medium",
                "false_positive_rate": "low",
                "prerequisites": [],
                "provides": ["open_ports", "services", "os_detection"],
                "best_for": [
                    "initial_reconnaissance",
                    "service_discovery",
                    "network_mapping",
                ],
            },
            "nuclei": {
                "primary_use": "vulnerability_scanning",
                "targets": ["url", "domain", "ip"],
                "protocols": ["http", "https"],
                "speed": "fast",
                "noise_level": "low",
                "false_positive_rate": "medium",
                "prerequisites": ["web_service"],
                "provides": ["cve_vulnerabilities", "misconfigurations", "exposures"],
                "best_for": [
                    "web_vulnerability_detection",
                    "cve_scanning",
                    "automated_checks",
                ],
            },
            "nikto": {
                "primary_use": "web_vulnerability_scanning",
                "targets": ["url", "domain"],
                "protocols": ["http", "https"],
                "speed": "slow",
                "noise_level": "high",
                "false_positive_rate": "high",
                "prerequisites": ["web_service"],
                "provides": ["web_vulnerabilities", "server_info", "dangerous_files"],
                "best_for": [
                    "comprehensive_web_scanning",
                    "server_enumeration",
                    "dangerous_files",
                ],
            },
            "ffuf": {
                "primary_use": "content_discovery",
                "targets": ["url", "domain"],
                "protocols": ["http", "https"],
                "speed": "fast",
                "noise_level": "medium",
                "false_positive_rate": "low",
                "prerequisites": ["web_service"],
                "provides": ["hidden_directories", "files", "parameters"],
                "best_for": [
                    "directory_bruteforcing",
                    "file_discovery",
                    "parameter_fuzzing",
                ],
            },
        }

    def _initialize_analysis_strategies(self) -> Dict[str, List[str]]:
        """Define analysis strategies for different scenarios"""
        return {
            "quick_assessment": ["nmap", "nuclei"],
            "comprehensive_web": ["nmap", "nuclei", "ffuf", "nikto"],
            "network_focused": ["nmap"],
            "web_focused": ["nuclei", "ffuf"],
            "stealth_mode": ["nuclei"],
            "thorough_investigation": ["nmap", "nuclei", "ffuf", "nikto"],
        }

    def analyze_target(
        self, target: str, context: Dict[str, Any] = None
    ) -> AnalysisContext:
        """Analyze the target to determine its characteristics"""

        # Parse target to determine type and components
        target_info = self._parse_target(target)

        # Create analysis context
        analysis_context = AnalysisContext(
            target=target,
            target_type=target_info["type"],
            protocol=target_info.get("protocol"),
            port=target_info.get("port"),
            path=target_info.get("path"),
            previous_results=context.get("previous_results", {}) if context else {},
            risk_level=context.get("risk_level", "medium") if context else "medium",
            time_budget=context.get("time_budget", 300) if context else 300,
        )

        return analysis_context

    def _parse_target(self, target: str) -> Dict[str, Any]:
        """Parse target to extract components and determine type"""

        target_info = {"type": "unknown"}

        # Check if it's a URL
        if target.startswith(("http://", "https://")):
            parsed = urllib.parse.urlparse(target)
            target_info.update(
                {
                    "type": "url",
                    "protocol": parsed.scheme,
                    "domain": parsed.hostname,
                    "port": parsed.port,
                    "path": parsed.path,
                }
            )

        # Check if it's an IP address
        elif re.match(r"^(\d{1,3}\.){3}\d{1,3}$", target):
            target_info.update({"type": "ip", "ip": target})

        # Check if it's a network range
        elif "/" in target and re.match(r"^(\d{1,3}\.){3}\d{1,3}/\d{1,2}$", target):
            target_info.update({"type": "network", "network": target})

        # Assume it's a domain
        else:
            # Remove protocol if present
            clean_target = target.replace("http://", "").replace("https://", "")
            if "/" in clean_target:
                domain, path = clean_target.split("/", 1)
                target_info.update(
                    {"type": "domain", "domain": domain, "path": f"/{path}"}
                )
            else:
                target_info.update({"type": "domain", "domain": clean_target})

        return target_info

    def recommend_tools(
        self, context: AnalysisContext, strategy: str = "auto"
    ) -> List[Dict[str, Any]]:
        """Recommend tools and their configurations based on context"""

        if strategy == "auto":
            strategy = self._select_strategy(context)

        # Get base tool list from strategy
        base_tools = self.analysis_strategies.get(strategy, ["nmap", "nuclei"])

        # Filter tools based on target compatibility
        compatible_tools = []
        for tool_name in base_tools:
            tool_info = self.tool_capabilities[tool_name]
            if self._is_tool_compatible(tool_info, context):
                compatible_tools.append(tool_name)

        # Generate tool configurations
        tool_configs = []
        for tool_name in compatible_tools:
            config = self._generate_tool_config(tool_name, context)
            if config:
                tool_configs.append(config)

        # Order tools by execution priority
        tool_configs = self._prioritize_tools(tool_configs, context)

        return tool_configs

    def _select_strategy(self, context: AnalysisContext) -> str:
        """Select appropriate analysis strategy based on context"""

        # Consider target type
        if context.target_type == "network":
            return "network_focused"

        # Consider time budget
        if context.time_budget < 180:  # Less than 3 minutes
            return "quick_assessment"
        elif context.time_budget > 900:  # More than 15 minutes
            return "thorough_investigation"

        # Consider risk level
        if context.risk_level == "low":
            return "stealth_mode"
        elif context.risk_level == "high":
            return "comprehensive_web"

        # Check if web service is likely
        if context.protocol in ["http", "https"] or context.port in [
            80,
            443,
            8080,
            8443,
        ]:
            return "web_focused" if context.time_budget < 600 else "comprehensive_web"

        # Default strategy
        return "quick_assessment"

    def _is_tool_compatible(
        self, tool_info: Dict[str, Any], context: AnalysisContext
    ) -> bool:
        """Check if a tool is compatible with the target context"""

        # Check target type compatibility
        if context.target_type not in tool_info["targets"]:
            return False

        # Check protocol compatibility if specified
        if context.protocol and tool_info.get("protocols"):
            if context.protocol not in tool_info["protocols"]:
                return False

        # Check prerequisites
        prerequisites = tool_info.get("prerequisites", [])
        for prereq in prerequisites:
            if not self._check_prerequisite(prereq, context):
                return False

        return True

    def _check_prerequisite(self, prerequisite: str, context: AnalysisContext) -> bool:
        """Check if a prerequisite is met"""

        if prerequisite == "web_service":
            # Web service is likely if target is URL or common web ports
            return (
                context.target_type == "url"
                or context.protocol in ["http", "https"]
                or context.port in [80, 443, 8080, 8443, 3000, 5000, 8000]
                or self._has_previous_web_service_detection(context)
            )

        return True

    def _has_previous_web_service_detection(self, context: AnalysisContext) -> bool:
        """Check if previous results indicate web service presence"""

        if not context.previous_results:
            return False

        # Check nmap results for web services
        nmap_results = context.previous_results.get("nmap", {})
        if nmap_results:
            # Look for web ports in open ports
            for host in nmap_results.get("hosts", []):
                for port in host.get("ports", []):
                    if port.get("port") in [80, 443, 8080, 8443]:
                        return True
                    service = port.get("service", "").lower()
                    if any(
                        web_service in service
                        for web_service in ["http", "web", "apache", "nginx"]
                    ):
                        return True

        return False

    def _generate_tool_config(
        self, tool_name: str, context: AnalysisContext
    ) -> Dict[str, Any]:
        """Generate intelligent configuration for a specific tool"""

        tool_info = self.tool_capabilities[tool_name]
        config = {
            "tool": tool_name,
            "priority": self._calculate_priority(tool_name, context),
            "params": {},
        }

        # Generate tool-specific parameters
        if tool_name == "nmap":
            config["params"] = self._generate_nmap_config(context)
        elif tool_name == "nuclei":
            config["params"] = self._generate_nuclei_config(context)
        elif tool_name == "nikto":
            config["params"] = self._generate_nikto_config(context)
        elif tool_name == "ffuf":
            config["params"] = self._generate_ffuf_config(context)

        return config

    def _calculate_priority(self, tool_name: str, context: AnalysisContext) -> int:
        """Calculate execution priority for a tool (higher number = higher priority)"""

        base_priority = {
            "nmap": 100,  # Always run first for reconnaissance
            "nuclei": 80,  # Fast and reliable vulnerability detection
            "ffuf": 60,  # Content discovery
            "nikto": 40,  # Comprehensive but noisy
        }

        priority = base_priority.get(tool_name, 50)

        # Adjust based on context
        if context.risk_level == "low" and tool_name == "nikto":
            priority -= 20  # Reduce nikto priority in stealth mode

        if context.time_budget < 300 and tool_name in ["nikto"]:
            priority -= 30  # Deprioritize slow tools in time-constrained scenarios

        if context.target_type == "url" and tool_name in ["nuclei", "ffuf"]:
            priority += 10  # Boost web tools for URL targets

        return priority

    def _generate_nmap_config(self, context: AnalysisContext) -> Dict[str, Any]:
        """Generate intelligent nmap configuration"""

        config = {
            "target": self._format_target_for_nmap(context),
            "timing": "T3",  # Normal timing by default
        }

        # Adjust timing based on risk level
        if context.risk_level == "low":
            config["timing"] = "T2"  # Slower, stealthier
        elif context.risk_level == "high":
            config["timing"] = "T4"  # Faster

        # Adjust scan type based on target
        if context.target_type == "network":
            config["scan_type"] = "tcp_syn"
            config["ports"] = "top-ports 100"  # Limit ports for network scans
        else:
            config["scan_type"] = "tcp_syn"
            config["ports"] = "top-ports 1000"

        # Enable service detection for detailed analysis
        config["service_detection"] = True

        # Enable OS detection for non-stealth modes
        if context.risk_level != "low":
            config["os_detection"] = True

        return config

    def _generate_nuclei_config(self, context: AnalysisContext) -> Dict[str, Any]:
        """Generate intelligent nuclei configuration"""

        config = {
            "target": self._format_target_for_nuclei(context),
            "severity": ["medium", "high", "critical"],  # Focus on actionable findings
        }

        # Adjust templates based on context
        if context.time_budget < 300:
            # Quick scan - focus on CVEs and critical misconfigurations
            config["templates"] = ["cve", "misconfig"]
        elif context.time_budget > 600:
            # Comprehensive scan
            config["templates"] = ["cve", "misconfig", "exposed-panels", "wordpress"]
        else:
            # Balanced scan
            config["templates"] = ["cve", "misconfig"]

        # Adjust concurrency based on risk level
        if context.risk_level == "low":
            config["concurrency"] = 10
            config["rate_limit"] = 50
        else:
            config["concurrency"] = 25
            config["rate_limit"] = 150

        return config

    def _generate_nikto_config(self, context: AnalysisContext) -> Dict[str, Any]:
        """Generate intelligent nikto configuration"""

        config = {"target": self._format_target_for_nikto(context), "timeout": 10}

        # Determine SSL usage
        if context.protocol == "https" or context.port == 443:
            config["ssl"] = True
            config["port"] = context.port or 443
        else:
            config["ssl"] = False
            config["port"] = context.port or 80

        # Adjust aggressiveness based on risk level
        if context.risk_level == "low":
            config["user_agent"] = (
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            )

        return config

    def _generate_ffuf_config(self, context: AnalysisContext) -> Dict[str, Any]:
        """Generate intelligent ffuf configuration"""

        config = {
            "target": self._format_target_for_ffuf(context),
            "wordlist": "common_directories",
            "threads": 40,
        }

        # Adjust based on context
        if context.time_budget < 300:
            config["wordlist"] = "common_directories"  # Smaller wordlist
            config["threads"] = 20
        elif context.time_budget > 600:
            config["wordlist"] = "common_files"  # More comprehensive
            config["extensions"] = ["php", "html", "txt", "xml", "json"]

        # Set intelligent status code matching
        config["match_status"] = [200, 204, 301, 302, 307, 401, 403, 405]

        # Adjust aggressiveness based on risk level
        if context.risk_level == "low":
            config["delay"] = 500  # 500ms delay
            config["threads"] = 10

        return config

    def _format_target_for_nmap(self, context: AnalysisContext) -> str:
        """Format target for nmap"""
        if context.target_type == "url":
            # Extract domain from URL
            parsed = urllib.parse.urlparse(context.target)
            return parsed.hostname or context.target
        return context.target

    def _format_target_for_nuclei(self, context: AnalysisContext) -> str:
        """Format target for nuclei"""
        if context.target_type == "url":
            return context.target
        elif context.target_type in ["domain", "ip"]:
            # Try both HTTP and HTTPS
            return f"http://{context.target}"
        return context.target

    def _format_target_for_nikto(self, context: AnalysisContext) -> str:
        """Format target for nikto"""
        if context.target_type == "url":
            parsed = urllib.parse.urlparse(context.target)
            return parsed.hostname or context.target
        return context.target

    def _format_target_for_ffuf(self, context: AnalysisContext) -> str:
        """Format target for ffuf"""
        if context.target_type == "url":
            base_url = context.target.rstrip("/")
            return f"{base_url}/FUZZ"
        elif context.target_type in ["domain", "ip"]:
            return f"http://{context.target}/FUZZ"
        return f"{context.target}/FUZZ"

    def _prioritize_tools(
        self, tool_configs: List[Dict[str, Any]], context: AnalysisContext
    ) -> List[Dict[str, Any]]:
        """Sort tools by execution priority"""
        return sorted(tool_configs, key=lambda x: x["priority"], reverse=True)

    def should_continue_analysis(
        self, results: Dict[str, Any], context: AnalysisContext
    ) -> bool:
        """Determine if analysis should continue based on current results"""

        # Always continue if no results yet
        if not results:
            return True

        # Check if we found critical vulnerabilities
        critical_found = False
        for tool_result in results.values():
            if self._has_critical_findings(tool_result):
                critical_found = True
                break

        # If critical vulnerabilities found and in quick mode, might stop
        if critical_found and context.time_budget < 300:
            return False

        # Continue if we haven't exceeded time budget
        # (This would need actual time tracking in implementation)
        return True

    def _has_critical_findings(self, tool_result: Dict[str, Any]) -> bool:
        """Check if a tool result contains critical findings"""

        # This would analyze the actual tool output
        # For now, implement basic logic
        result_text = str(tool_result).lower()

        critical_indicators = [
            "critical",
            "rce",
            "sql injection",
            "xss",
            "remote code execution",
            "privilege escalation",
            "directory traversal",
            "file inclusion",
        ]

        return any(indicator in result_text for indicator in critical_indicators)

    def generate_analysis_summary(
        self, results: Dict[str, Any], context: AnalysisContext
    ) -> str:
        """Generate intelligent summary of analysis results"""

        summary = f"# 🧠 Intelligent Vulnerability Analysis Summary\n\n"
        summary += f"**Target:** {context.target} ({context.target_type})\n"
        summary += f"**Strategy:** {self._select_strategy(context)}\n"
        summary += f"**Risk Level:** {context.risk_level.title()}\n\n"

        # Analyze overall risk
        risk_score = self._calculate_risk_score(results)
        summary += f"## 📊 Risk Assessment\n\n"
        summary += f"**Overall Risk Score:** {risk_score}/100\n"
        summary += f"**Risk Category:** {self._get_risk_category(risk_score)}\n\n"

        # Key findings summary
        key_findings = self._extract_key_findings(results)
        if key_findings:
            summary += f"## 🔍 Key Findings\n\n"
            for i, finding in enumerate(key_findings[:5], 1):
                summary += f"{i}. **{finding['title']}** - {finding['description']}\n"
            summary += "\n"

        # Tool effectiveness analysis
        summary += f"## 🛠️ Tool Effectiveness\n\n"
        for tool_name, result in results.items():
            effectiveness = self._assess_tool_effectiveness(tool_name, result, context)
            summary += f"- **{tool_name.title()}:** {effectiveness}\n"

        return summary

    def _calculate_risk_score(self, results: Dict[str, Any]) -> int:
        """Calculate overall risk score from results"""

        base_score = 0

        for tool_name, result in results.items():
            if self._has_critical_findings(result):
                base_score += 40
            elif "high" in str(result).lower():
                base_score += 25
            elif "medium" in str(result).lower():
                base_score += 15
            else:
                base_score += 5

        return min(base_score, 100)

    def _get_risk_category(self, score: int) -> str:
        """Convert risk score to category"""
        if score >= 80:
            return "🔴 Critical"
        elif score >= 60:
            return "🟠 High"
        elif score >= 40:
            return "🟡 Medium"
        elif score >= 20:
            return "🟢 Low"
        else:
            return "⚪ Minimal"

    def _extract_key_findings(self, results: Dict[str, Any]) -> List[Dict[str, str]]:
        """Extract key findings from all tool results"""

        findings = []

        # This would parse actual results - simplified for now
        for tool_name, result in results.items():
            result_str = str(result).lower()

            if "critical" in result_str:
                findings.append(
                    {
                        "title": f"Critical vulnerability found by {tool_name}",
                        "description": "Immediate attention required",
                    }
                )
            elif "sql injection" in result_str:
                findings.append(
                    {
                        "title": "SQL Injection vulnerability",
                        "description": "Database compromise possible",
                    }
                )
            elif "xss" in result_str:
                findings.append(
                    {
                        "title": "Cross-Site Scripting vulnerability",
                        "description": "Client-side code execution possible",
                    }
                )

        return findings

    def _assess_tool_effectiveness(
        self, tool_name: str, result: Dict[str, Any], context: AnalysisContext
    ) -> str:
        """Assess how effective a tool was for the given context"""

        # Analyze result content
        if not result or not str(result).strip():
            return "❌ No results - tool may have failed"

        result_str = str(result).lower()

        if "error" in result_str or "failed" in result_str:
            return "⚠️ Execution errors detected"

        # Count findings
        finding_indicators = ["vulnerability", "finding", "discovered", "detected"]
        finding_count = sum(
            result_str.count(indicator) for indicator in finding_indicators
        )

        if finding_count > 10:
            return "✅ Highly effective - many findings"
        elif finding_count > 5:
            return "✅ Effective - several findings"
        elif finding_count > 0:
            return "⚪ Partially effective - some findings"
        else:
            return "⚪ Limited effectiveness - few findings"
