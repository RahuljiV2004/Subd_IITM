"""
Advanced vulnerability intelligence module for MCP server
Provides AI-driven analysis, tool selection, and strategic assessment capabilities
"""

import logging
from typing import Dict, Any, List

logger = logging.getLogger(__name__)


class VulnerabilityIntelligence:
    """Advanced vulnerability intelligence for MCP server with AI-driven analysis"""

    def __init__(self):
        self.strategies = {
            "quick": {
                "name": "Quick Assessment",
                "tools": ["nmap"],
                "estimated_time": 60,
            },
            "comprehensive": {
                "name": "Comprehensive Scan",
                "tools": ["nmap", "nuclei", "ffuf"],
                "estimated_time": 300,
            },
            "web": {
                "name": "Web Application Focus",
                "tools": ["nuclei", "ffuf", "nikto"],
                "estimated_time": 180,
            },
            "stealth": {
                "name": "Stealth Mode",
                "tools": ["nmap"],
                "estimated_time": 120,
            },
        }

    async def analyze_target_data(
        self, target: str, flask_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Intelligent analysis of target data from Flask backend to assess risk and characteristics

        Args:
            target: Target domain or IP
            flask_data: Comprehensive data from Flask backend

        Returns:
            Analysis results with risk assessment, attack surface, and recommendations
        """
        try:
            logger.info(f"Analyzing target data for {target}")

            # Extract key metrics from Flask data
            subdomain_count = len(flask_data.get("subdomains", []))
            service_count = len(flask_data.get("services", []))
            vuln_count = len(flask_data.get("vulnerabilities", []))
            tech_count = len(flask_data.get("technologies", []))
            ssl_issues = len(flask_data.get("ssl_issues", []))

            # Risk level assessment
            risk_score = 0
            risk_factors = []

            # Subdomain enumeration assessment
            if subdomain_count > 50:
                risk_score += 3
                risk_factors.append("Large attack surface with many subdomains")
            elif subdomain_count > 10:
                risk_score += 2
                risk_factors.append("Moderate attack surface")
            elif subdomain_count > 0:
                risk_score += 1
                risk_factors.append("Limited attack surface")

            # Service exposure assessment
            if service_count > 20:
                risk_score += 3
                risk_factors.append("High service exposure")
            elif service_count > 5:
                risk_score += 2
                risk_factors.append("Moderate service exposure")

            # Existing vulnerability assessment
            if vuln_count > 10:
                risk_score += 4
                risk_factors.append("Multiple vulnerabilities already identified")
            elif vuln_count > 0:
                risk_score += 2
                risk_factors.append("Some vulnerabilities present")

            # SSL/TLS issues
            if ssl_issues > 0:
                risk_score += 1
                risk_factors.append("SSL/TLS configuration issues")

            # Technology diversity assessment
            if tech_count > 10:
                risk_score += 2
                risk_factors.append("Complex technology stack")
            elif tech_count > 5:
                risk_score += 1
                risk_factors.append("Diverse technology stack")

            # Risk level classification
            if risk_score >= 8:
                risk_level = "critical"
            elif risk_score >= 6:
                risk_level = "high"
            elif risk_score >= 3:
                risk_level = "medium"
            else:
                risk_level = "low"

            # Attack surface assessment
            if subdomain_count > 50 or service_count > 20:
                attack_surface = "extensive"
            elif subdomain_count > 20 or service_count > 10:
                attack_surface = "large"
            elif subdomain_count > 5 or service_count > 3:
                attack_surface = "medium"
            else:
                attack_surface = "small"

            # Complexity score (0-10)
            complexity_score = min(
                10, (subdomain_count // 10) + (service_count // 5) + (tech_count // 3)
            )

            # Identify potential attack vectors
            attack_vectors = []
            if service_count > 0:
                attack_vectors.append("Network service exploitation")
            if any(
                "web" in tech.lower() for tech in flask_data.get("technologies", [])
            ):
                attack_vectors.append("Web application attacks")
            if ssl_issues > 0:
                attack_vectors.append("SSL/TLS vulnerabilities")
            if subdomain_count > 10:
                attack_vectors.append("Subdomain takeover risks")

            # Technology analysis
            technologies = flask_data.get("technologies", [])
            web_technologies = [
                tech
                for tech in technologies
                if any(
                    web_keyword in tech.lower()
                    for web_keyword in ["web", "http", "apache", "nginx", "iis"]
                )
            ]

            analysis_result = {
                "target": target,
                "risk_level": risk_level,
                "risk_score": risk_score,
                "risk_factors": risk_factors,
                "attack_surface": attack_surface,
                "complexity_score": complexity_score,
                "attack_vectors": attack_vectors,
                "metrics": {
                    "subdomains": subdomain_count,
                    "services": service_count,
                    "vulnerabilities": vuln_count,
                    "technologies": tech_count,
                    "ssl_issues": ssl_issues,
                },
                "technologies": technologies,
                "web_technologies": web_technologies,
                "has_web_services": len(web_technologies) > 0,
                "analysis_timestamp": flask_data.get("timestamp", ""),
            }

            logger.info(
                f"Analysis complete for {target}: Risk={risk_level}, Surface={attack_surface}"
            )
            return analysis_result

        except Exception as e:
            logger.error(f"Error analyzing target data for {target}: {e}")
            # Return basic analysis on error
            return {
                "target": target,
                "risk_level": "unknown",
                "risk_score": 0,
                "risk_factors": [f"Analysis error: {str(e)}"],
                "attack_surface": "unknown",
                "complexity_score": 0,
                "attack_vectors": [],
                "metrics": {"error": str(e)},
                "technologies": [],
                "web_technologies": [],
                "has_web_services": False,
                "analysis_timestamp": "",
            }

    def generate_tool_recommendations(
        self, analysis: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Generate intelligent tool recommendations based on target analysis

        Args:
            analysis: Analysis result from analyze_target_data

        Returns:
            List of tool recommendations with priority and rationale
        """
        try:
            recommendations = []
            metrics = analysis.get("metrics", {})
            risk_level = analysis.get("risk_level", "medium")
            attack_surface = analysis.get("attack_surface", "medium")
            has_web_services = analysis.get("has_web_services", False)

            # Nmap - Network reconnaissance (almost always recommended)
            if metrics.get("services", 0) > 0 or risk_level in ["high", "critical"]:
                recommendations.append(
                    {
                        "tool": "nmap",
                        "priority": "high",
                        "rationale": "Services detected - comprehensive port scanning recommended",
                        "estimated_value": "High",
                        "arguments": {"scan_type": "comprehensive"},
                        "execution_probability": 0.9,
                    }
                )
            else:
                recommendations.append(
                    {
                        "tool": "nmap",
                        "priority": "medium",
                        "rationale": "Standard network reconnaissance",
                        "estimated_value": "Medium",
                        "arguments": {"scan_type": "basic"},
                        "execution_probability": 0.7,
                    }
                )

            # Nuclei - Vulnerability scanning
            if (
                risk_level in ["high", "critical"]
                or metrics.get("vulnerabilities", 0) > 0
            ):
                recommendations.append(
                    {
                        "tool": "nuclei",
                        "priority": "high",
                        "rationale": "High risk target - comprehensive vulnerability scanning essential",
                        "estimated_value": "High",
                        "arguments": {"severity": "critical,high,medium"},
                        "execution_probability": 0.95,
                    }
                )
            elif has_web_services or attack_surface in ["large", "extensive"]:
                recommendations.append(
                    {
                        "tool": "nuclei",
                        "priority": "medium",
                        "rationale": "Web services detected - targeted vulnerability scanning recommended",
                        "estimated_value": "High",
                        "arguments": {"severity": "high,medium"},
                        "execution_probability": 0.8,
                    }
                )

            # FFUF - Directory/file discovery
            if metrics.get("subdomains", 0) > 5 or has_web_services:
                priority = "high" if metrics.get("subdomains", 0) > 20 else "medium"
                recommendations.append(
                    {
                        "tool": "ffuf",
                        "priority": priority,
                        "rationale": f"Large attack surface ({metrics.get('subdomains', 0)} subdomains) - directory discovery valuable",
                        "estimated_value": "Medium",
                        "arguments": {
                            "wordlist": "common",
                            "extensions": "php,html,txt,js",
                        },
                        "execution_probability": 0.75 if priority == "high" else 0.6,
                    }
                )

            # Nikto - Web application scanning
            if has_web_services and (
                risk_level in ["medium", "high", "critical"]
                or metrics.get("subdomains", 0) > 10
            ):
                recommendations.append(
                    {
                        "tool": "nikto",
                        "priority": "medium",
                        "rationale": "Web technologies detected - web application vulnerability scanning recommended",
                        "estimated_value": "Medium",
                        "arguments": {"check_type": "comprehensive"},
                        "execution_probability": 0.7,
                    }
                )

            # Sort by priority and execution probability
            priority_order = {"critical": 4, "high": 3, "medium": 2, "low": 1}
            recommendations.sort(
                key=lambda x: (
                    priority_order.get(x["priority"], 1),
                    x.get("execution_probability", 0.5),
                ),
                reverse=True,
            )

            logger.info(f"Generated {len(recommendations)} tool recommendations")
            return recommendations

        except Exception as e:
            logger.error(f"Error generating tool recommendations: {e}")
            # Return basic recommendations on error
            return [
                {
                    "tool": "nmap",
                    "priority": "medium",
                    "rationale": "Basic network reconnaissance (fallback)",
                    "estimated_value": "Medium",
                    "arguments": {},
                    "execution_probability": 0.8,
                }
            ]

    def should_execute_tool(
        self, recommendation: Dict[str, Any], analysis: Dict[str, Any], depth: str
    ) -> bool:
        """
        Determine if a tool should be executed based on recommendation and scan depth

        Args:
            recommendation: Tool recommendation with priority and probability
            analysis: Target analysis results
            depth: Scan depth (surface, moderate, deep, comprehensive)

        Returns:
            Boolean indicating if tool should be executed
        """
        try:
            execution_probability = recommendation.get("execution_probability", 0.5)
            priority = recommendation.get("priority", "medium").lower()

            # Depth-based thresholds
            depth_thresholds = {
                "surface": 0.9,  # Only execute very high probability tools
                "moderate": 0.7,  # Execute high probability tools
                "deep": 0.5,  # Execute medium+ probability tools
                "comprehensive": 0.3,  # Execute most tools
            }

            threshold = depth_thresholds.get(depth, 0.7)

            # Priority overrides
            if priority == "high" and depth in ["moderate", "deep", "comprehensive"]:
                return True
            elif priority == "critical":
                return True  # Always execute critical priority

            return execution_probability >= threshold

        except Exception as e:
            logger.error(f"Error determining tool execution: {e}")
            return True  # Default to execution on error

    def select_strategy(
        self, target: str, risk_level: str = "medium", time_budget: int = 300
    ) -> Dict[str, Any]:
        """Select the best scanning strategy based on parameters"""

        # Simple strategy selection logic
        if time_budget < 90:
            return self.strategies["quick"]
        elif "http" in target or "www" in target:
            return self.strategies["web"]
        elif risk_level == "low":
            return self.strategies["stealth"]
        else:
            return self.strategies["comprehensive"]

    def analyze_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Basic analysis of scan results"""
        return {
            "summary": "Scan completed successfully",
            "risk_score": "Medium",
            "recommendations": ["Review identified services", "Apply security patches"],
            "findings_count": len(results.get("findings", [])),
        }
